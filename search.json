[{"title":"下载 4399 FLASH 游戏","url":"/2021/08/28/4399download/","content":"快速帮助http://sda.4399.com/4399swf/\n后面拼接上HTML文件中找到的swf后缀文件相对的相对地址，例如\nhttp://sda.4399.com/4399swf/upload_swf/ftp/20070524/4.swf\n\n\n年份够久 就可以有情怀Adobe Flash Player——一个足够暴露年龄的名词，如果你的网龄足够长的话，一定不会感到陌生，但是早在2017年，Adobe 就宣布会在2020年底前停止对 Flash 的支持和开发。现在，各种浏览器纷纷宣布他们的 Flash 淘汰计划，其中就包括了微软，随着2021年的到来，Adobe 也正式终止了旗下 Flash 产品的支持，因此我们再也无法像往常一样在 Chrome 浏览器中游玩例如4399提供的 Flash 游戏  \n\n“公司已经选择关闭Flash，因为其他技术（如HTML5）已经足够成熟，足以提供Flash播放器可行的替代品”。不过他同时也说：“在互联网时代，很少有技术能产生如此深远而积极的影响。” \n\n首先在前端抓取4399的游戏加载地址Flash 游戏文件一般后缀都是 swf 文件，于是打开 F12 检查 HTML文件在JavaScript代码中用文本匹配搜索有关 .swf 后缀的文本地址\n例如图中的 _strGamePath=&quot;/upload_swf/ftp/20070524/4.swf&quot;;\n不过很显然 这只是一个相对地址，仅凭相对地址我们是没有办法下载的,我们还需要一个绝对地址\n继续分析网页的结构，在 js 文件夹下有一个 serversda.js 文件,打开它我们会发现有关 FTP 服务器的描述\n\nvar webServer = &quot;//sda.4399.com/4399swf&quot;;    var sPicServer = &quot;img.4399.net:8080&quot;;\n其中 http://sda.4399.com/4399swf 就是我们要找的前缀在后面再拼接上我们的之前找到的swf相对地址，用浏览器或下载工具打开，就可以下载游戏文件了  \n\n安装无广告无插件的国际版adobe flash player下载地址1：https://www.lanzoui.com/b083kq90h 密码：cyxt  \n将下载的 swf 文件用 adobe flash player 打开即可运行\n\n","tags":["工具"]},{"title":"阿里巴巴编码规范（Java）","url":"/2021/08/06/AlibabaCodeFormat/","content":"编程规约注释注释规范1. 类、类属性、类方法的注释必须使用Javadoc规范，使用/**内容*/格式，不得使用// xxx方式\n2. 所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能\n3. 所有的类都必须添加创建者和创建日期\n4. 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐\n5. 所有的枚举类型字段必须要有注释，说明每个数据项的用途\n6. 与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。\n7. 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改\n8. 谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。\n9. 对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。\n10. 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担\n11. 特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码\n\n文案规范\n中文文案排版指北\n写给大家看的中文排版指南\n\n单行注释\n注释内容与左侧的双斜线之间保留一个空格// good comment//  bad comment//bad comment\n\n文档注释\n标准的文档注释写法为 /** … */，一定要避免将其与多行注释混淆/** * good comment *//* * bad comment */\n方法描述与左侧的 * 号之间保留一个空格，与下方的参数 / 返回 / 异常说明之间保留一个空行/** * good comment * * @param id * @return * @throws *//** *bad comment * @param id * @return * @throws */\n命名风格1. 代码命名不能以下划线或者美元符号开头或者结尾2. 代码命名不能以中文拼音或者中文拼音与英文混合方式3. 类名使用UpperCamCamelCase风格，但DO、PO、DTO、VO、BO等除外4. 方法名、参数名、变量名统一使用lowerCamelCase，必须遵守驼峰命名5. 常量名全部大写，单词间用下划线隔开6. 抽象类必须以Abstract或者Base开头，异常类必须以Exception结尾，测试类以测试的类的名称开头Test结尾7. 类型与中括号紧挨相连标示数组8. POJO类中布尔类型变量不要加is前缀9. 包名统一小写，点分隔符有且有一个自然语义单词10. 避免在父子类和不同代码块中采用相同变量名11. 避免不规范的缩写命名12. 在对元素命名时用完整单词组合表达其意13. 常量和变量命名时，表示类型放在词尾，如：idList、TERMINATED_TREAD_COUNT14. 接口、类、方法、模块使用设计模式，命名时要体现具体模式15. 接口类中的方法和属性不要加任何修饰符，并加上有效的javadoc。16. 接口和实现类的命名规则：    1、对于service和dao类，实现类必须用Impl结尾；    2、如果是形容能力的接口名称，取对应的形容词为接口名 AbstractTranslator实现 Translatable接口17. 枚举类名加Enum后缀，枚举成员名称全大写，单词间用下划线隔开18. 各层命名规范：    A) Service/DAO层命名规约        1.获取单个对象的方法用get做前缀        2.获取多个对象的方法用list做前缀，如：listObjects        3.获取统计值的方法用count做前缀        4.插入方法用save/insert做前缀        5.删除方法用delete/remove做前缀        6.修改方法用update做前缀    B）领域模型命名规范        1.数据对象：xxxDO, xxx为数据库表名        2.数据传输对象：xxxDTO,xxx为业务模型相关名称        3.展示对象：xxxVO，xxx一般为网页名称        4.POJO是对DO、DTO、VO、BO的统称，禁止xxxPOJO\n常量定义1. 代码中禁止出现魔法值2. 在Long类型中赋值，数值后使用大写L3. 不要在一个常量类中维护所有常量，要根据功能分开维护4. 常量的复用层次：    1.跨应用：放在二方库中，通常在constant目录下    2.应用内：放在一方库中，通常在constant目录下    3.子工程内：放在当前子工程constant目录下    4.包内共享常量：当前包下单独的constant目录下    5.类内共享常量：直接在类内部private static final定义5. 如果变量值只在固定的范围内变化，用enum类型定义\n代码格式1. 如果大括号代码为空直接&#x27;&#123;&#125;&#x27;,大括号内有代码则：左大括号左侧不换行，右侧换行；右大括号右侧换行，左侧如果不跟else等代码换行，否则不换行2. 小括号和字符之间不能有空格，括号内字符和运算符之间有空格 如：if (a == b)3. if、for、while、do、switch与括号之间必须有空格4. 任何二目、三目运算符前后必须有空格5. 采用4个空格，禁止使用tab6. 注释的双斜线和内容要有空格7. 强制类型转换时，右括号与强制转换值之间不用空格8. 单行字符不超过120个，超过要换行9. 方法在定义和传参时，必须要加空格10. IDE的text file encoding 设置为UTF-8；IDE中 文件的换行符使用Unix格式11. 单个方法尽量不超过80行12. 不同逻辑、不同语义、不同业务之间的代码插入一个空行分隔符\nOOP规约1. 不用一个类型的对象引用来访问静态方法和静态属性，直接类名访问即可2. 所有覆写方法，必须加@Override注解3. 相同业务含义，相同参数类型才能使用java可变参数4. 外部依赖或者二方库依赖的接口，不能修改方法签名。接口过时必须用@Deprecated 注解，并说明新接口或者新服务是什么5. 不能使用过时的类或者方法6.  Object的equals方法容易抛出空指针，应使用常量或者确定值的对象来调用equals7. 所有整型包装类之间的值比较都用equals 方法比较8. 浮点数之间的等值判断，基本类型不能用==，包装类不能用equals。    解决方案：(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。            (2) 使用BigDecimal来定义值，再进行浮点数的运算操作。9. 定义DO类时，属性类型要数据库字段类型相匹配10. 防止精度丢失，禁止使用BigDecimal(double)方式将double对象转换成BigDecimal。建议使用BigDecimal的valueOf方法11. 基本类型和包装类型的使用标准    1.所有POJO的属性必须用包装类型    2.RPC方法的参数和返回值必须使用包装类型    3.所有局部变量使用基本变量12. 所有POJO 不要对其属性设置默认值13. 序列化类新增时不要修改其serialVersionUID字段14. 构造方法里禁止加任何业务处理逻辑，有要加在init()15. POJO类必须要写toString方法16. 禁止在POJO类中对属性xxx 同时存在isXxx()和getXxx()17. 使用索引访问用String的split方法得到数组时，需要对最后一个分隔符有无内容做检查18.   一个类有多个构造方法或者多个同名方法，要按照顺序来。19. 类中的方法顺序 ：共有方法-&gt; 私有方法 -&gt; get/set20. setter方法中参数名称和成员变量名称一致，不要在getter和setter方法中加业务逻辑21. 循环体内用StringBuilder的append方法进行扩展22. final可以修饰类，方法，变量。23. 慎用Object的clone方法24. 类成员与方法访问控制从严    1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。         2） 工具类不允许有public或default构造方法。    3） 类非static成员变量并且与子类共享，必须是protected。    4） 类非static成员变量并且仅在本类使用，必须是private。    5） 类static成员变量如果仅在本类使用，必须是private。     6） 若是static成员变量，考虑是否为final。    7） 类成员方法只供类内部调用，必须是private。     8） 类成员方法只对继承类公开，那么限制为protected。\n集合处理1. hashCode和equals 的处理遵循以下规则：    1）只要覆写equals ，就必须要覆写hashCode    2）因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。    3）如果自定义对象作为Map的键，那么必须覆写hashCode和equals。2. ArrayList的subList结果不能强转ArrayList。3. 使用map的keySet()、values()、entrySet()方法返回对象后不可以对其进行添加元素的操作4. Collections类返回的对象，如：emptyList()/singletonList()等都是immutablelist不可对其进行添加或者删除元素的操作5. 在subList场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生ConcurrentModificationException 异常6. 使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一致、长度为0的空数组7. 在使用Collection接口任何实现类的addAll()方法时，一定要对输入的集合做NEP判断8. 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常    说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。9. 泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，而&lt;? super T&gt;不能使用get方法，作为接口调用赋值时易出错10. 在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行instanceof判断，避免抛出ClassCastException异常11. 不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁12. 在JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然Arrays.sort，Collections.sort 会抛IllegalArgumentException 异常。    说明：三个条件如下    1） x，y 的比较结果和y，x 的比较结果相反。    2） x&gt;y，y&gt;z，则x&gt;z。    3） x=y，则x，z 比较结果和y，z 比较结果相同。13. 集合泛型定义时，在JDK7 及以上，使用diamond 语法或全省略。14. 集合初始化时，指定集合初始值大小。15. 使用entrySet 遍历Map 类集合KV，而不是keySet 方式进行遍历16. 高度注意Map类集合K/V能不能存储null值的情况，如下表格：17. 合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。18. 利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作\n\n\n\n集合类\nKey\nValue\nSuper\n说明\n\n\n\nHashTable\n不允许为null\n不允许为null\nDictionary\n线程安全\n\n\nConcurrentHashMap\nHashTable\n不允许为null\n不允许为null\nAbstractMap\n\n\nTreeMap\n不允许为null\n允许为null\nAbstractMap\n线程不安全\n\n\nHashMap\n允许为null\n允许为null\nAbstractMap\n线程不安全\n\n\n\n\n并发处理1. 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。2. 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。3. 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程4. 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险5. SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。6. 必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块进行回收7. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁8. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。9. 在使用阻塞等待获取锁的方式中，必须在try代码块之外，并且在加锁方法与try代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在finally中无法解锁。10. 在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同11. 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据12. 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用ScheduledExecutorService则没有这个问题13. 资金相关的金融敏感信息，使用悲观锁策略14. 使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果15. 避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降16. 在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The &quot;Double-Checked Locking is Broken&quot; Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型17. volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。18. HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险19. ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题\n控制语句1. 在一个switch块内，每个case要么通过continue/break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有2. 当switch括号内的变量类型为String并且此变量为外部参数时，必须先进行null判断3. 在if/else/for/while/do语句中必须使用大括号4. 在高并发场景中，避免使用”等于”判断作为中断或退出的条件5. 表达异常的分支时，少用if-else方式6. 除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性7. 不要在其它表达式（尤其是条件表达式）中，插入赋值语句8. 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。9. 避免采用取反逻辑运算符10. 接口入参保护，这种场景常见的是用作批量操作的接口11. 下列情形，需要进行参数校验：     1） 调用频次低的方法。    2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致 中间执行回退，或者错误，那得不偿失。    3） 需要极高稳定性和可用性的方法。     4） 对外提供的开放接口，不管是RPC/API/HTTP接口。    5） 敏感权限入口。12. 下列情形，不需要进行参数校验：    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。     2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。    3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。\n其他1. 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度2. velocity调用POJO类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调用isXxx()方法3. 后台输送给页面的变量必须加$!&#123;var&#125;——中间的感叹号4. 注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法5. 获取当前毫秒数System.currentTimeMillis(); 而不是new Date().getTime();6. 日期格式化时，传入pattern中表示年份统一使用小写的y7. 不要在视图模板中加入任何复杂的逻辑8. 任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存9. 及时清理不再使用的代码段或配置信息\n异常日志异常处理1. java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch方式处理。如NullPointException、IndexOutOfBoundsException。2. 异常不要用作流程控制、条件控制。3. catch是要分清是稳定代码和非稳定代码，对于非稳定代码catch尽可能的按照异常类型分类。4. 捕获异常一定要做处理，如果不想处理就抛给上层调用者。5. 有try块放在事务中，catch异常后如果需要回滚事务，一定要注意手动回滚事务。6. finally块中必须对资源对象、流对象进行关闭，有异常也要catch。7. 不要在finally块中使用return8. 捕获的异常要和抛的异常匹配或者捕获的异常是抛异常的父类9. 在调用RPC、二方包、或动态生成类的相关方法时，捕获异常一定要用Throwable类拦截10. 方法的返回值可以是null，但是必须要说明什么情况返回null11. 防止NEP：    1. 返回类型是基本类型 ，return包装类型的对象。    2. 数据库查询的结果可能是null    3. 集合里的元素即时isNotEmpty，取出来的元素也可能是null    4. 远程调用返回对象时，必须要进行判空处理    5. 对于Session中的数据要进行判空处理    6. 级联调用有可能产生空指针12. 定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等13. 对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”14. 避免出现重复的代码（Don&#x27;t Repeat Yourself），即DRY原则\n\n日志规约1. 应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架 SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一2. 所有日志文件至少保存15天，因为有些异常具备以“周”为频次发生的特点。网络运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日志不少于6个月3. 应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，如stats/monitor/access等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找4. 在日志输出时，字符串变量之间的拼接使用占位符的方式5. 对于trace/debug/info级别的日志输出，必须进行日志级别的开关判断6. 避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false7. 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出8. 谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志9.  可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警10. 尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。【强制】国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息\n\n单元测试1. 好的单元测试必须遵守AIR原则2. 单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证3. 保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序4. 单元测试是可以重复执行的，不能受到外界环境的影响5. 对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别6. 核心业务、核心应用、核心模块的增量代码确保单元测试通过7. 单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下8. 单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%9. 编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量10. 对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据11. 和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识12. 对于不可测的代码在适当的时机做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码13. 在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例14. 单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例15. 为了更方便地进行单元测试，业务代码应避免以下情况： 1.构造方法中做的事情过多。 2. 存在过多的全局变量和静态方法。 3. 存在过多的外部依赖。 4. 存在过多的条件语句16. 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。 1. 单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。 2. 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。 3. 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障\n\n安全规约1. 隶属于用户个人的页面或者功能必须进行权限控制校验2. 用户敏感数据禁止直接展示，必须对展示数据进行脱敏3. 用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库4. 用户请求传入的任何参数必须做有效性验证5. 禁止向HTML页面输出未经安全过滤或未正确转义的用户数据6. 表单、AJAX提交必须执行CSRF安全验证7. 在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损8. 发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略\n\nMySQL数据库建表规约1. 表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否）2. 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑3. 表名不使用复数名词4. 禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字5. 主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名6. 小数类型为decimal，禁止使用float和double7. 如果存储的字符串长度几乎相等，使用char定长字符串类型8. varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率9. 表必备三字段：id, create_time, update_time10. 表的命名最好是遵循“业务名称_表的作用”11. 库名与应用名称尽量一致12. 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 1） 不是频繁修改的字段。 2） 不是varchar超长字段，更不能是text字段。3） 不是唯一索引的字段。13. 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释14. 单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表15. 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度\n\n索引规约1. 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引2. 超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引3. 在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可4. 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决5. 如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能6. 利用覆盖索引来进行查询操作，避免回表7. 利用延迟关联或者子查询优化超多分页场景8. SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好9. 建组合索引的时候，区分度最高的在最左边10. 防止因字段类型不同造成的隐式转换，导致索引失效11. 创建索引时避免有如下极端误解： 1） 宁滥勿缺。认为一个查询就需要建一个索引。 2） 宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。 3） 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。\n\nSQL语句1. 不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关2. count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为03. 当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题4. 使用ISNULL()来判断是否为NULL值5. 代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句6. 不得使用外键与级联，一切外键概念必须在应用层解决7. 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性8. 数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句9. in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内10. 如果有国际化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别11. TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句\n\nORM映射1. 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明2. POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射3. 不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个POJO类与之对应4. sql.xml配置参数使用：#&#123;&#125;，#param# 不要使用$&#123;&#125; 此种方式容易出现SQL注入5. iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用6. 不允许直接拿HashMap与Hashtable作为查询结果集的输出7. 更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间8. 不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储9. @Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等10. &lt;isEqual&gt;中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；&lt;isNotEmpty&gt;表示不为空且不为null时执行；&lt;isNotNull&gt;表示不为null值时执行\n\n工程结构应用分层1. 图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web层，也可以直接依赖于Service层，依此类推\n\n\n\n\n• 开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制、流量控制等。• 终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。• Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。• Service层：相对具体的业务逻辑服务层。• Manager层：通用业务处理层，它有如下特征： 1） 对第三方平台封装的层，预处理返回结果及转化异常信息。 2） 对Service层通用能力的下沉，如缓存方案、中间件通用处理。 3） 与DAO层交互，对多个DAO的组合复用。• DAO层：数据访问层，与底层MySQL、Oracle、Hbase等进行数据交互。• 外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。\n2.（分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager/Service层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。\n3. • DO（Data Object）：此对象与数据库表结构一一对应，通过DAO层向上传输数据源对象。\n    • DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。\n    • BO（Business Object）：业务对象，由Service层输出的封装业务逻辑的对象。\n    • AO（Application Object）：应用对象，在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。\n    • VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。\n    • Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。\n\n二方库依赖1.定义GAV遵从以下规则： 1） GroupID格式：com.&#123;公司/BU &#125;.业务线 [.子业务线]，最多4级。 说明：&#123;公司/BU&#125; 例如：alibaba/taobao/tmall/aliexpress等BU一级；子业务线可选。 正例：com.taobao.jstorm 或 com.alibaba.dubbo.register 2） ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。 正例：dubbo-client / fastjson-api / jstorm-tool 3） Version：详细规定参考下方2. 二方库版本号命名方式：主版本号.次版本号.修订号 1）主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。 2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。 3） 修订号：保持完全兼容性，修复BUG、新增次要功能特性等。3. 线上应用不要依赖SNAPSHOT版本（安全包除外）4. 二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证5. 二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象6. 依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致7. 禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version8. 底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现9. 所有pom文件中的依赖声明放在&lt;dependencies&gt;语句块中，所有版本仲裁放在&lt;dependencyManagement&gt;语句块中10. 二方库不要有配置项，最低限度不要再增加配置项11.为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：   1）精简可控原则。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。   2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。\n\n服务器1. 高并发服务器建议调小TCP协议的time_wait超时时间2. 调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）3. 给JVM环境参数设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息4. 在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC 后调整堆大小带来的压力5. 服务器内部重定向使用forward；外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险\n\n设计规约1. 存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档2. 在需求分析阶段，如果与系统交互的User超过一类并且相关的User Case超过5个，使用用例图来表达更加清晰的结构化需求3. 如果某个业务对象的状态超过3个，使用状态图来表达并且明确状态变化的各个触发条件4. 如果系统中某个功能的调用链路上的涉及对象超过3个，使用时序图来表达并且明确各调用环节的输入与输出5. 如果系统中模型类超过5个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系6. 如果系统中超过2个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示7. 需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界8. 类在设计与实现时要符合单一原则9. 谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现10. 系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护11. 系统设计时，注意对扩展开放，对修改闭合12. 系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况13. 避免如下误解：敏捷开发 = 讲故事 + 编码 + 发布14. 系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码15. 设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点16. 系统架构设计的目的：    1.确定系统边界。确定系统在技术层面上的做与不做。    2.确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。    3.确定指导后续设计与演化的原则。使后续的子系统或模块设计在规定的框架内继续演化。    4.确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等17. 在做无障碍产品设计时，需要考虑到：    1. 所有可交互的控件元素必须能被tab键聚焦，并且焦点顺序需符合自然操作逻辑。    2.用于登陆校验和请求拦截的验证码均需提供图形验证以外的其它方式。    3.自定义的控件类型需明确交互方式。\n\n\n抄袭自:https://www.jianshu.com/p/1884cdc54409https://github.com/ClarkWong/treehouse\n\n","tags":["开发"]},{"title":"香蕉♂dark道东","url":"/2021/08/02/BananaAvenueEast/","content":" \n\n\n策划/填词/调音：蔡涂坤PV：晏策去月光林地了  \n\n《香蕉♂大道东》是林泄填词，罗dark佑谱曲的歌曲。香蕉大道是新日暮里的著名地标，每年都有数百万哲学家前来旅♂游。在香蕉大道上，你可以观看当地的舞团表演“香蕉舞”，舞者们穿上香蕉头套跳劲爆♂拉丁舞。在新日暮里传统文化中，香蕉是智慧的象征。泄迦摩尼就是因为吃了香蕉才获得了很大的智慧，所以香蕉也被称为智慧之果、哲学之果，当地人认为经常跳香蕉舞会自己都变得聪明，因此香蕉舞被定为新日暮里中小学生广播♂体操。\n\n香蕉♂大道东\n\n\n《香蕉♂大道东》牢牢抓住了批站用户对近年哲学封禁既担忧又想展望的心态，成功引发了用户讨论哲学前途的热潮。\n\n\n\n在一千年以后的未来，草地铺满了大地，科技发展到了顶点，社会开始返璞归真，人们自由地探讨哲学的奥秘，向全宇宙邀请了各方哲学的集大成者，希望将极乐♂世界的领域容扩到整个宇宙，让一切都在哲学的光辉下闪闪fa♂光每一滴血源自宇宙宇宙已经137亿岁所以你也137亿岁而这，仅仅是哲学的冰山一角在宇宙无法到达的地方，想象力 哲学思考可以横跨百亿光年，  去到一个十全十美的地方。  \n\n\n香蕉大道西又香蕉大道东\n香蕉大道东转香蕉大道中\n香蕉大道东上I dont do it know\n香蕉大道中boy nexr door如潮涌\n\n有个沙县朋友在地牢门口\n戴着黑色帽子说帕秋莉go\n每次摔跤随我一起来back here\n辣的酸萝卜它味道有点餿\n香蕉一声拜拜远去日暮里\n刘dark华不发米玩玩新游戏\n这个世界太乱弟弟so horny\n但是哲学可能要faking coming\n\n空即是色 色即是空 空即是色即是色即是空\n空即是色 色即是空 空即是色即是色即是空\n空即是色 色即是空 空即是色即是色即是空\n空即是色 色即是空 空即是色即是色即是空\n\n香蕉大道西又香蕉大道东\n香蕉大道东转香蕉大道中\n香蕉大道东上I dont do it know\n香蕉大道中boy nexr door如潮涌\n有个沙县朋友在发廊门口\n理发不说谢谢皮革有点臭\n到了摔跤那天大为要发愁\n不愿乖乖站好陈乔恩乱动\n尻比一声拜拜远去日暮里\n易建联也放弃deep dark fantasy\n这个夜色太黑男孩会哭泣\n但是哲学家们永远不言弃\n\n香蕉大道西又香蕉大道东\n香蕉大道东转香蕉大道中\n香蕉大道东上I dont do it know\n香蕉大道中boy nexr door如潮涌\n\n","tags":["哲♂学"]},{"title":"数据库事务处理技术","url":"/2021/08/30/Database-transaction-processing-techniques/","content":" 第22讲 数据库事务处理技术为了更好的性能，我们需要并行处理数据库事务\n什么是并发控制？就比如我们买票\n如果大家同时买起点终点、日期、车次相同 的车票，会否买到座位相重复的车票？\n很显然如果服务不能很好的进行并发控制，就会导致一张票被卖了两次，进而出现我们不想要的结果\n常见的三种并发问题：\n\n丢失修改（同一数据被两个事务同时操作，其中一个事务的结果被另一个事务的结果覆盖）\n不可重复读（第一次读和第二次读结果不一样）\n脏读（读到了已被回滚的数据）\n\n什么是事务事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应 用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制， 以便数据库管理系统能够提供一致性状态转换的保证。\n一个事务可处理一个数据或一条记录（从帐户A过户5000到帐户B上），也可能处理一批数据或一批记录\n例如：下面的操作即为一个事务\nread(A);A := A – 5000;write(A);read(B);B := B + 5000;write(B);\n\n所以说\n并发控制就是 通过事务微观 交错执行次序 的正确安排， 保证事务宏观上的独立性、完整性和正确性\n事务的ACID特性\n原子性Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对 DB而言，要么全做，要么全不做\n\n一致性Consistency⭐: DBMS保证事务的操作状态是正确的，符合一致性的操作 规则，不能出现三种典型的不一致性。它是进一步由隔离性来保证的。\n\n隔离性Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个 事务T1和T2, 即使并发执行，也相当于或 者先执行了T1,再执行T2;或者先执行了T2,再执行T1。\n\n持久性Durability: DBMS保证已提交事 务的影响是持久的，被撤销事务的影响是可恢复的。\n\n\n并发调度什么是事务调度(schedule)：一组事务的基本步(读、写、其他控 制操作如加锁、解锁等)的一种执行顺序称为对这组事务的一个调度。 \n并发(或并行)调度：多个事务从宏观上看是并行执行的，但其微观上的基本 操作(读、写)则是交叉执行的。\n事务调度之正确性当且仅当在这个并发调度下所得到的新数据库结果与分别串行地运行这些事务所得的新数据库完全一致，则说调度是正确的。\n事务调度之可串行性如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个串行调度相同，则我们说这个调度是可串行化的 (Serializable)或具有可串行性(Serializability)。\n\n\n可串行化调度一定是正确的并行调度，但正确的并行调度，却未必都是可串行化的调度\n并行调度的正确性是指内容上结果正确性，而可串行性是指形式上结果正确性，便于操作。\n可串行化的等效串行序列不一定唯一\n\n事务调度之冲突调度中一对连续的动作，它们满足：如果它们的顺序交换，那么涉及的事务中至少有一个事务的行为会改变。\n有冲突的两个操作是不能交换次序的，没有冲突的两个事务是可交换的\n\n同一个事务的任何两个操作都是冲突的\n\n\n  不同事务对同一元素的两个写操作是冲突的\n  不同事务对同一元素的一读一写操作是冲突的\n\n事务调度之冲突可串行性一个调度，如果通过交换相邻两个无冲突的操作能够转换到某一个串行的调度，则称此调度为冲突可串行化的调度。    \n\n  冲突可串行性是比可串行性要严格的概念\n  满足冲突可串行性，一定满足可串行性；反之不然\n\n冲突可串行性判别算法\n构造一个前驱图(有向图)\n\n结点是每一个事务Ti。如果Ti的一个操作与Tj的一个操作发生冲突，且Ti在 Tj前执行，则绘制一条边，由Ti指向Tj, 表征Ti要在Tj前执行。\n\n测试检查: 如果此有向图没有环，则是冲突可串行化的\n\n\n一道习题：冲突可串行的判定\n基于封锁的并发控制方法锁的概念锁是控制并发的一种手段，是数据库元素上的并发控制标志\n关于锁的基本知识点\n  每一数据元素都有唯一的锁\n  每一事务读写数据元素前，要获得锁\n  如果被其他事务持有该元素的锁，则要等待\n  事务处理完成后要释放锁\n  锁本身并不能保证冲突可串行性，只是为调度提供了控制的手段，具体如何使用锁需要说明——不同协议\n\n封锁协议之锁的类型排他锁X只有一个事务能读和写，其他任何事务都不能读、写\n共享锁S所有事务都可以读，但任何事务都不能写\n更新锁U初始读，以后可以升级为写\n增量锁I区分增量更新和其他类型的更新\n封锁协议0级到3级协议（加锁的时机）\n 0级协议  有写要求的数据对象A加排他锁，不再访 问后即刻解锁。可防止丢失修改，但允许 脏读，允许重复读错误\n 1级协议 有写要求的数据对象A加排他锁，事务提 交时刻解锁。可防止丢失修改，可恢复,防止脏读，允许重复读错误\n 2级协议  有写要求的数据对象A加排他锁，事务提 交时刻解锁。有读要求的数据对象B加共 享锁，不再访问后即刻解锁。可防止丢失 修改，防止脏读，防止重复读错误，但是不能解决幻读\n 3级协议 有写要求的数据对象A加排他锁，事务提 交时刻解锁。有读要求的数据对象B加共 享锁，事务提交时刻解锁。防止所有不一致性\n\n脏读、不可重复读、幻读： 脏读：\n所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。\n也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。\n 不可重复读：\n事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。\n也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。\n 幻读：\n事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。\n也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。\nSQL之隔离性级别读未提交(read uncommitted) —相当于0级协议 \n读已提交 (read committed) —相当于1级协议 \n可重复读(repeatable read)—相当于2级协议\n可串行化(serializable) —相当于3级协议 \n详细说明\n两段封锁协议是一种基于锁的并发控制方法。读写数据之前，每个事务中所有封锁请求先于任何一个解锁请求。\n两阶段：加锁段和解锁段。加锁段不能有解锁操作，解锁段不能有加锁操作。\n 作用\n两段封锁协议是可以保证冲突可串行性的。\n注意：两段封锁协议是可能产生死锁的协议\n基于时间戳的并发控制方法基于时间戳的并发控制方法：借助于时间戳，强制使一组并发事务的交叉执行，等价于一个特定顺序的串行执行\n具体操作就是执行时判断冲突，如无冲突，予以执行；如有冲突，则撤销事务，并 重启该事务，此时该事务获得了一个更大的时间戳， 表明是后执行的事务。\n有哪些冲突：\n\n读-读无冲突；\n\n读-写或写-读冲突；\n\n写-写冲突\n\n\n具体规则：\n对DB中的每个数据元素x，系统保留其上的最大时间戳\nRT(x): 即R-timestamp(x) 读过该数据事务中最大的时间戳，即最后读x的事务的时间戳。\nWT(x): 即W-timestamp(x)写过该数据事务中最大的时间戳，即最后写x的事务的时间戳。\n事务的时间戳\nTS(T) 即TimeStamp\n读-写并发：(读-写、写-读)若T事务读x，则将T的时间戳TS与WT(x)比较:若TS大(T后进行)，则允许T操作，并且更改RT(x)为max{RT(x),TS}；否则，有冲突，撤回T，重启T。若T事务写x，则将T的时间戳TS与RT(x)比较：若TS大(T后进行)，则允许T操作，并且更改WT(x)为max{WT(x),TS}；否则，有冲突，撤回T重做。\n写-写并发 \n若T事务写x，则将T的时间戳TS与WT(x)比较：若TS大，则允许T写，并且更改WT(x)为T的时间戳；否则有冲突，T撤回重做。\n前述规则可以解决事务T过晚的读和过晚的写\n但是这两种“事实上 不可实现的”冲 突可以避免了，实用性很有限\n因此引入另一种调度规则\n对DB中的每个数据元素x，系统保留其上的最大时间戳\nRT(x): 即R-timestamp(x) \n  读过该数据事务中最大的时间戳，即最后读x的事务的时间戳。\nWT(x): 即W-timestamp(x) \n  写过该数据事务中最大的时间戳，即最后写x的事务的时间戳。\nC(x): x的提交位。 \n​    该位为真，当且仅当最近写x的事务已经提交。\nC(x)的目的是避免出现事务读另一事务U所写数据然后U终止或者被撤销这样的情况。\n对来自事务T的读写请求，调度器可以：\n\n同意请求\n\n撤销/终止T，并重启具有新时间戳的T(终止+重启，被称回滚)\n\n推迟T，并在以后决定是终止T还是同意请求(如果请求是读，且此读可能是 脏的)\n\n\n调度规则\n\n假设调度器收到请求rT(X)\n\n(1)如果TS(T)&gt;=WT(x), 此读是事实上可实现的\n 如C(x)为真，    同意请求。如果TS(T)&gt;RT(x), 置RT(x):=TS(T); 否则不改变RT(x).\n 如C(x)为假，推迟Ｔ直到C(x)为真或写x的事务终止。\n(2)如果TS(T)&lt;WT(x), 此读是事实上不可实现的\n回滚T(终止并重启T)；(过晚的读)\n\n假设调度器收到请求wT(X)\n\n(1)如果TS(T)&gt;=RT(x), 且TS(T)&gt;=WT(x), 此写是事实上是可实现的\n为x写入新值；置WT(x):=TS(T)；置C(x):=false.\n(2)如果TS(T)&gt;=RT(x),但是TS(T)&lt;WT(x)，此写是事实上可实现的。但x 已经有一个更晚的值\n如果C(x)为真，那么前一个x的写已提交；则忽略T的写；继续进行。(托马斯写规则)如果C(x)为假，则我们需推迟T，直到C(x)为真或写x的事务终止。\n(3)如果TS(T)&lt;RT(x), 此写是事实上不可实现的T必须回滚。(过晚的写)\n\n假设调度器收到提交T的请求。\n\n它必须找到T所写的所有数据库元素x, 并置C(x):=true。\n如果有任何等待x被提交的事务，这些事务就被允许继续进行。\n\n假设调度器收到终止T的请求\n\n像前述步骤一样确定回滚T。\n那么任何等待T所写元素x的事务必须重新尝试 读或写，看这一动作现在T的写被终止后是否合法。\n基于时间戳的并发控制的思想\n 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。 为每一数据库元素保存读时间戳和写时间戳，以记录读或写该数据元素的最 后的事务。 通过在事务读写数据时判断是否存在冲突(读写冲突、写读冲突、写写冲突) 来强制事务以可串行化的方式执行。\n基于有效性确认的并发控制方法基于有效性确认的并发控制的思想\n 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。 为每一活跃事务保存其读写数据的集合，RS(T)：事务T读数据的集合； WS(T)：事务T写数据的集合。 通过对多个事务的读写集合，判断是否有冲突(存在事实上不可实现的行为)，即有效性确认，来完成事务的提交与回滚，强制事务以可串行化的方式执行\n基于有效性确认的调度器\n 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。 每一事务读写数据的集合\n\nRS(T)：事务T读数据的集合；\n\nWS(T)：事务T写数据的集合。\n\n\n事务分三个阶段进行 \n\n读阶段。事务从数据库中读取读集合中的所有元素。事务还在其局部地址空间计算它将要写的所有值；\n有效性确认阶段。调度器通过比较该事务与其它事务的读写集合  来确认该事务的有效性。\n写阶段。事务往数据库中写入其写集合中元素的值。   每个成功确认的事务是在其有效性确认的瞬间执行的。   并发事务串行的顺序即事务有效性确认的顺序。\n\n调度器维护三个集合\n\nSTART集合。已经开始但尚未完成有效性确认的事务集合。对此集合中的事务，调度器维护START(T)，即事务T开始的时间。\nVAL集合。已经确认有效性但尚未完成第3阶段写的事务。对此集合中的事务，调度器维护START(T)和VAL(T)，即T确认的时间。\nFIN集合。已经完成第3阶段的事务。对这样的事务T,START(T), VAL(T)和FIN(T)，即T完成的时间。\n\n有效性确认规则\n-(1)对于所有已经过有效性确认, 且在T开始前没有完成的U（U已经过有效性确认）, 即对于满足 FIN(U)&gt;START(T)（U在T开始前没有完成。）的U,检测:\nRS(T) ∩WS(U)是否为空。 \n若为空，则确认。否则，不予确认。\n其含义是：如果一个较早的事务U现在正在写入T应该 读过的某些对象，则T的有效性不能确认\n(2)对于所有已经过有效性确认，且在T有效性确认前没有完成的U（U有效性已经成功确认）, 即对于 满足FIN(U)&gt;VAL(T)的U（U在T进入其有效性确认阶段以前没有完成）, 检测：WS(T) ∩WS(U)是否为空。 \n若为空，则确认。否则，不予确认。\n其含义是：如果T在有效性确认后可能比一个较早的事 务先写某个对象，则T的有效性不能确认\n","tags":["教程"]},{"title":"数据库事务处理技术-故障恢复","url":"/2021/09/01/Database-transaction-processing-technology-failure-recovery/","content":"第23讲 数据库事务处理技术-故障恢复数据库的故障类型及其影响典型的数据库故障\n\n事务故障某一个程序(事务)自身运行错误所引起的故障影响该程序(事务)本身\n\n系统故障\n由于掉电、非正常关机等所引起的故障影响正在运行的事务以及数据库缓冲区, 数据库缓冲区将涉及正在 运行和已经运行的事务\n\n介质故障\n由于介质损坏等所引起的 故障影响是全面的，既影响内存中的数据, 又影响介质 中存储的数据\n\n\n数据库故障恢复的宏观思路 三种类型故障：事务故障、系统故障和介质故障 三种恢复手段:    事务的撤消与重做, 运行日志和备份 两个重要时刻：检查点和转储点\n每个事务都会读写某些元素READ(X,t):将元素X读到事务的局部变量t中；\nWRITE(X,t):将事务局部变量t写回元素X；\nINPUT(X):将元素X从磁盘读入到内存缓冲区中；\nOUTPUT(X):将元素X写回到磁盘中。\n每个事务都以提交或者撤销结束COMMIT：事务提交\nABORT：事务撤销\nDBMS在故障发生时需要保障事务\n持久性\n\n  已提交的事务——缓冲区内容保证写回磁盘\n  未提交的事务——缓冲区内容不能影响磁盘\n\n\n原子性\n事务的所有操作，要么全都执行，要么全不执行。\n\n\n注意：缓冲区内容和磁盘内容并不是时刻保持一致的。\n不同缓冲区策略Force:内存中的数据最晚在commit的时候写入磁盘。\nNo steal:不允许在事务commit之前把内存中的数据写入磁盘。\nNo force:内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘。此时在系统崩溃的时候可能还没写入到磁盘，需要Redo,此方式较为灵活。\nSteal:允许事务commit之前把内存中的数据写入磁盘，此时若系统在commit之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要Undo,此方式同样较为灵活。\n当前最常用：Steal + No force\n什么是日志？一个包含日志记录的、只能追加的顺序文件, 不同事务的日志记录交错存储，按发生时间存储。\n发生系统故障时，使用日志进行恢复:\n故障时已提交的事务，重做(Redo)\n故障时未提交的事务，撤销(Undo)\nUndo型日志及其故障恢复对于任一事务T，按下列顺序向磁盘输出T的日志信息： 首先，&lt;T, X, v&gt;被写到日志中 其次，OUTPUT(X) 最后，或被写到日志中 注意：Undo型日志仅保留旧值。&lt;T, X, v&gt;，v为X原来的值(X的旧值) Undo型日志：“将事务改变的所有数据写到磁盘前不能提交该事务”\n利用undo型日志进行恢复首先，确定每一个事务是否已完成?\n&lt;START T&gt;….&lt;COMMIT T&gt;….\t= yes&lt;START T&gt;….&lt;ABORT T&gt;…….\t= no(已结束，但未完成)&lt;START T&gt;………………………\t= no然后，从日志的尾部开始按日志记录的反序，处理每一日志 记录，撤销未完成事务的所有修改&lt;COMMIT T&gt;:\t标记T已完成&lt;ABORT T&gt;: 标记T已结束但未完成&lt;T,X,v&gt;: 如果T未完成，则将X=v写回磁盘；否则跳过；&lt;START T&gt;: 跳过\n\n\n检查点及其使用\n\n静止检查点：\n周期性地对日志设置检查点停止接受新的事务, 等到所有当前活跃事务提交或终止，并在日志中 写入了COMMIT或ABORT记录后将日志刷新到磁盘，写入日志记录，并再次刷新日志\n\n非静止检查点在设置检查点时不必关闭系统，允许新事务进入写入一条&lt;START CKPT(T1,…,Tk)&gt;其中T1,…,Tk 是所有活跃的未结束的事务继续正常的操作，直到T1,…,Tk都完成时，写入\n\n\n故障需恢复到所 遇到的第一个检查点\nRedo型日志及其故障恢复Redo型日志Undo型日志的问题“将事务改变的所有数据写到磁盘前不能 提交该事务”—如何解决?对于任一事务T，按下列顺序向磁盘输出T的日志信息：\n首先，&lt;T, X, v&gt;被写到日志中其次，&lt;COMMIT T&gt;被写到日志中最后，OUTPUT(X)注意：redo型日志保留新值。&lt;T, X, v&gt;，v为X更新后的值(X的新值)注意：与undo型的差别，在后两步，先写提交记录后输出，还是先输出，再写提交记录。\n利用redo日志进行恢复确定每一个事务是否已完成?\n&lt;START T&gt;….&lt;COMMIT T&gt;…. =yes&lt;START T&gt;….&lt;ABORT T&gt;…….=no(已结束，但未完成)&lt;START T&gt;………………………\t= no\n从日志的起始位置开始按日志记录的正序处理每一日志记录，重做已提交事务的所有修改：\n&lt;COMMIT T&gt;:\t标记T已完成&lt;ABORT T&gt;:标记T已结束但未完成&lt;T,X,v&gt;: 如果T已完成，则将X=v写回磁盘；否则跳过；&lt;START T&gt;: 跳过\n\n\n\n检查点\n\n非静止检查点在进行检查点设置时不必关闭系统，允许新事务进入写入一条&lt;START CKPT(T1,…,Tk)&gt;其中T1,…,Tk 是所有活跃的未结束的事务将所有已提交的事务写回磁盘，继续正常的操作，直到T1,…,Tk都完成时，写入\n\nUndo/Redo结合型日志及其故障恢复Redo型日志与Undo型日志的比较\nUndo型日志:\n\nOUTPUT必须先做。\n\n如果可见, T确定地已将所有其数据写回磁盘，因此不必重做 –– 但可能引起性能下降(因可能频繁地写磁盘)\n\n\nRedo型日志：\n\nOUTPUT必须后做。\n\n如果不可见, T确定地没有将其任何数据写回到磁盘， 因此无需撤销 –– 但灵活性差(数据必须在Commit后才可见)\n\n\n如更喜欢灵活性 – 需要采用Undo/Redo型日志\nUndo/Redo型日志对于任一事务T，按下列顺序向磁盘输出T的日志信息：\n- 第(1)步，&lt;T, X, u, v&gt;被写到日志中- 第(2)or(3)步，&lt;COMMIT T&gt;被写到日志中- 第(3)or(2)步，OUTPUT(X)- 注意：undo/redo型日志既保留新值v，也保留旧值u。\n注意：与undo型和redo型的差别，在后两步。\nRedo型是先写提交记录 后输出；\nundo型是先输出，再写提交记录；\nundo/redo型则无所谓谁先谁 后，只要保证&lt;T,X,u,v&gt;被先于OUTPUT写完即可。\n利用undo/Redo型日志进行恢复\n首先，确定每一个事务是否已完成?\n&lt;START T&gt;….&lt;COMMIT T&gt;….\t= yes&lt;START T&gt;….&lt;ABORT T&gt;……. = no(已结束，但未完成)&lt;START T&gt;………………………\t= no\n自前向后地，按日志记录的正序，重做所有已提交的事务；\n自后向前，按日志记录的反序，撤销所有未完成事务的所有修改。\n&lt;COMMIT T&gt;:\t标记T已完成&lt;ABORT T&gt;:标记T已结束但未完成&lt;T,X,u,v&gt;: 如果T未完成，则将X=u写回磁盘；否则将x=v写回磁盘；&lt;START T&gt;: 跳过\n\n\n总而言之：自后向前地撤销所有未提交的事务；自前向后地重做所有已提交的事务；先做&lt;撤销&gt;，再做&lt;重做&gt;\n","tags":["教程"]},{"title":"对哲♂学的深刻认识","url":"/2021/08/03/DeepUnderstandingOfPhilosophy/","content":"哲♂学≠搞基哲♂学来源是㚻片，这是不可否认的事实；但哲♂学本质是给人带来愉♂悦以及深♂刻的思考的，而不是搞基的哲♂学只适合去追寻它的人（不要向不适合哲♂学的人强行展示或安利哲♂学，后果极有可能是引起他人的不爽）哲♂学是带领我们向上的哲♂学不存在歧视（包括：种族，肤色，出身地域，境界高低，是否是腐女等）哲♂学是善良的哲♂学是积极的哲♂学追求的是一种境界哲♂学崇尚自由哲♂学可以引领时尚哲♂学可以是虚无的哲♂学可以是坚硬的哲♂学不可以代替爱情，爱情同样不可以代替哲♂学。（每个兄贵都应该收获自己真挚的感♂情，而不是沉迷哲♂学无法自拔；也不能沉迷美色不思哲♂学）哲♂学是一种精神♂娱乐哲♂学可以成为一种信仰哲♂学可以成为力量哲♂学可以让人成为朋友哲♂学可以使人意志坚强哲♂学不能用金钱购买哲♂学的价值不能单纯的以金钱衡量哲♂学可以令人奋发向上哲♂学可以激发身体潜能哲♂学可以丰富大脑哲♂学可以增强体质哲♂学可以使人坚韧不拔哲♂学可以令人成长哲♂学可以丰富内涵哲♂学可以寻求新的自我哲♂学能令人充满精力哲♂学使人心境愉快哲♂学是一种难以用语言去形容的精神哲♂学是一种能量哲♂学是一门思想哲♂学是宽广的哲♂学是伟大的哲♂学的身躯很健壮哲♂学拥有无比伟大的动力哲♂学的来源是一切生命哲♂学发展其特长的生命体哲♂学是有生命的哲♂学不是黑暗的但可以是黑♂暗的哲♂学是光明的哲♂学是愉快的哲♂学是健康的哲♂学不是孤独的哲♂学有一群伙伴哲♂学需要你们的研究哲♂学需要你们\n","tags":["哲♂学"]},{"title":"Game-Cheating-Tutorial","url":"/2021/08/21/Game-Cheating-Tutorial/","content":"前言说明 :green_book:作者大学生一个,技术水平有限,而且学习方向也不是破解逆向相关的,有错误的地方还望大佬指点。\n再次说明 :rotating_light:教程以交流技术为主要目的,只学技术。\n关于教程 :smile:有很多东西作者是不懂的,毕竟作者当前水平也是处于[hello world]级别\n支持作者 :two_hearts:给我点个Star咯 ^_^ 让我有更多动力给你们分享更多教程\n正文机器码欺骗/Spoofer HWIDswmi-static-spooferhwidnegativespoofermutantVolumeSerialhdd_serial_spooferPasting.WinHardware_SpooferAimKit-Pasted-DriverTestSpooftalibanprotectionsownerfuckedhwid_spooferhwid-checker-mgOsu-BypassAntiOSHWIDbypass\n漏洞驱动利用/Vulnerability Driven Exploitationkdmapperkdmapper-1803-1903kdmapper-1803-2004kdmapper-1909gdrv-loaderEfiGuardDSEFixEfiDumpTDLUPGDSEDSharkDisableWin10PatchguardPocPPLKillerByePg\n内核读写驱动/Kernel Read And Write DriverKernel_Driver_Hackkernel-read-write-using-ioctlkm-um-communicationefi-memoryKernelBhopEFI_Driver_AccessmemdrvMdlReadWriteProcess-MDLBOOMCTL-hookKeProcessOverlayphysmem-ScannerMemoryMondma_ip_driverspcileech\n动态连接库注入/Dynamic Link Library InjectKernelmode-manual-mapping-through-IATmodmapdrvmapsmapDoubleAgentGenshin-BypassThePerfectInjectorinjdrvMemoryModule\n内核回调/Kernel CallbackObRegisterCallBacksByPassObRegisterCallBacksByPassCallbackExRemoveCallBacksCallbackDisablerExecutiveCallbackObjectskmextscbtest\n内核框架/Kernel FrameworkKernel-HijackBlackboneKernel-Bridgenorsefire\n游戏覆盖渲染/Game Overlay Renderingwda_monitor_trickdwm_overlaydxgkrnl_hookwindow_hijack\ncapcom利用/Capcom ExploitSafeMapperCapcomDriverCapcomLibsafe_capcomExploitCapcomCapcomDKOMppliblibcapcomlibelevate\nspeedfan利用/Speedfan ExploitSpeedFan-Exploit\ncpuz利用/Cpuz ExploitCPUZ-DSEFixStryker\n应用层内存读写/Application Layer Memory Read And WriteaccessNoBastianEUPMAccessHLeakervmreadLSASS-Usermode-Bypass\n反调试/Anti DebugScyllaHideMirageAnti-debugAnti-Anti-Debug\n字符串加密/String EncryptionxorstrskCrypter\n驱动级隐藏MasterHideTitanHide\n帮助库nt_wrapperKDUAntiCheat-Testing-Frameworkghidracutter\n反汇编/Disassemblyzydis\n游戏结构分析/Game Structural AnalysisReClassExReClass.NET\n进程内存保护/Process Memory DumpProcess-Dump\nUE4游戏分析/UE4 Game Analysisshootergame-HackUE4DumperUnrealEngineSDKGenerator\n腾讯保护/Tencent ProtectSecondProcess\n应用层挂钩/User Mode HookColdHookDetoursminhook\n内核层挂钩/Kernel Mode HookHookLibDdiMonHyperPlatformkernelhookHyperBoneWinAltSyscallHandlerEasyHookInfinityHookDetoursNTSyscallHookKasperskyHookSyscallTablesgbhv\n隐藏驱动/Kernel HidehiddenHideDriverHideDriver\n进程隐藏/Process HideHideProcess\n进程保护/Protect ProcessEQProtect\n驱动信息查看/Drive Information ViewWinObjEx64\n驱动痕迹/Drive TraceTraceCleaner\nBattlEyeSplendid ImplanterBattlEyeBE-BypassBEDaisyBottlEye\nUEFIumapdreamboot\nIDA pluginSigMaker-x64\nEasyAntiCheatEAC_dbpEac-BypassEACReversingCVEAC-2020\nValve Anti-CheatVAC BypassVACVAC Bypass Loadervac3_inhibitor\n堡垒之夜/Fortnitefortnite-cheat-source-publicFortniteCheatSourceFortnite-Offsets\n逃离塔克夫/Escape from TarkovNathans-Tarkov-Radar-Public\n反恐精英:全球攻势/Counterstrike Global OffensiveOsirisRPM-WPM-projectGarHal_CSGOheck_exewok-csgo-sdk-v2SpyExternal1337haxNIXWARE-CSGOGladiatorcheatz-v2.1master-guidehazedumper\nApex英雄/Apex legendsApexGaming.pyEzApexDMAAimbotAnotherApexDebugapex_dma_kvm_pub\n侠盗猎车手5/Grand Theft Auto Vgta5_cheats_1.50pHakesubVerison_GTAV_HackGTA5_Cheats_Native_Menu\n和平精英/Pubg Mobilepubg_mobile_memory_hacking_examples\n彩虹六号/Tom Clancy’s Rainbow Six Sieger6s-external-nuklear-hookR6SDKInternal-Rainbow-Six-CheatOverflowR6V2RainbowSixDmaKvm\n相关网站 一号选手 - 英文  二号选手 - 英文  三号选手 - 英文 \n","tags":["教程"]},{"title":"Java 程序员常读书单整理","url":"/2021/08/21/JavaBooks/","content":"Java 程序员常读书单整理，附下载地址，助力构建最强知识体系。但不限于 Java，包括设计模式、计算机网络、操作系统、数据库、数据结构与算法、大数据、架构、面试等等。\n\n”二哥，能不能给一套 Java 电子书的链接啊，最好是成体系的；我现在就想好好的学习，感觉和公司的一些同事差距有点大，想追赶上。纸质书有点沉，天天带在手边很不方便，尤其是上下班坐地铁的时候，都感觉看纸质书不太好意思，电子书不仅携带方便，还能不知不觉。“\n\n说实话，被很多小伙伴问过这样的问题，于是我下狠心，整理了半个多月的时间，终于从各个搜索网站上收集了上百本常用的 Java 电子书，真的是吃奶劲都使上了！\n确实，计算机方面的书籍都比较贵，而技术更新迭代又非常快，天天买纸质书确实不太能跟上节奏。那么，现在好了，再也不用担心这些问题了。\n\n入门\n工具\n框架\nStruts2\nSpring\nNetty\n\n\n数据库\nSQL\nMySQL\nRedis\nMongoDB\n\n\n并发编程\n底层\n性能优化\n设计模式\n操作系统\nLinux基础知识\nLinux环境编程\nLinux内核\n\n\n计算机网络\nLinux网络编程\nwireshark\n\n\n数据结构与算法\n面试\n大数据\n架构\n扩展\n其他语言\nC\nC++\nJavaScript\nPython\ngo\nJavaWeb\nJSP\nKotlin\ngroovy\n\n\nDDD\n区块链\n人工智能\n搜索引擎\n网络安全\n消息队列\n云计算\nAR&amp;VR\nDocker\nIoT\nKubernets\n测试\n\n\n管理\n加餐\n活着\n免责声明\n\n简单说一下我为什么要花半个多月的时间来整理这份书单。主要是因为很多读者的知识体系是零散的，不成系统的，况且技术书籍这么庞杂。有了我这份清单之后，那些没有经验或者经验有限的初学者，在学习的时候思路瞬间就开阔了许多：少走弯路，利用有限的精力，更加高效地学习。\n想应聘初级 Java 工程师，那只需要阅读入门、工具、框架和数据库方面的书籍就行了；\n如果想应聘 Java 高级工程师，那么就需要阅读并发编程、底层、性能优化方面的书籍；\n如果还想更进一步，那么就要着手阅读设计模式、操作系统、计算机网络、数据结构与算法等方面的书籍；\n记住一点，在应聘之前，请恶补一下面试方面的资料；\n如果时间充沛，大数据、架构、管理方面的书籍可以读起来；\n如果还有时间，DDD、区块链、人工智能、搜索引擎、网络安全、消息队列、云计算、容器、智能家居等等方面的书籍，就可以读起来了；\n作为一名程序员，技术方面也不能太过局限，想学习第二种编程语言的话，C、C++、JavaScript、Python、go 都可以选择；\n技术学累了，可以读一读理财金融方面的书籍，比如说香帅北大金融学课、李笑来的学习学习再学习，思维认知方面，强烈推荐《沉默的大多数》，我的偶像王小波的散文集。\n最后，不管怎样，活着最重要！\n入门\nJava 程序员进阶之路       百度云下载链接  密码:1thn\nHead First Java       百度云下载链接 提取码:c07s \nJava 核心技术卷       百度云下载链接 提取码:1fvj \nJava 编程思想       百度云下载链接  密码:9xcr\nJava 8 实战       百度云下载链接 提取码:nfbm \nJava 核心知识点整理       百度云下载链接 提取码:e6tl \nJava 基础核心总结       百度云下载链接 提取码:x2qi \n第一行代码 Java       百度云下载链接 提取码:zhuk \n疯狂 Java 讲义       百度云下载链接 提取码:em2k \n黑马程序员 Java 自学宝典       百度云下载链接 提取码:7mm0 \nJava 软件开发复习提纲       百度云下载链接 提取码:ztfu \nJava 程序设计语言       百度云下载链接 提取码:xc2a \nJava 从入门到精通       百度云下载链接 提取码:2msp \nJava 从小白到大牛       百度云下载链接 提取码:4oon \nJava 技术手册       百度云下载链接 提取码:wx6l \nJava 趣味编程 100 例       百度云下载链接 提取码:gfaq \nJava 入门 123       百度云下载链接 提取码:tdb0 \nJava 网络编程       百度云下载链接 提取码:6ovu \nGitHub 上标星 115k+ 的 Java 教程       百度云下载链接  密码:dz95\n\n工具\nMaven 实战       百度云下载链接  密码:daj5\nMaven 入门指南松哥版       百度云下载链接  密码:bztw\nGit 权威指南       百度云下载链接  密码:sdvy\nEclipse 插件开发学习笔记       百度云下载链接  密码:ri78\n日志系统手册（Log4j、SLF4J、Logback、Log4j 2）       百度云下载链接  密码:fxxy\nIntelliJ IDEA 简体中文专题教程（电子版-2015）       百度云下载链接  密码:wskm\nGitHub入门与实践       百度云下载链接  密码:kidr\n\n框架\nSpringBoot实战(第4版)       百度云下载链接  密码:y6c6\nSpringMVC 入门指南松哥版       百度云下载链接  密码:1j0h\nMyBatis 从入门到精通       百度云下载链接  密码:8vjv\nMyBatis 入门指南松哥版       百度云下载链接  密码:7zj7\nHibernate 实战       百度云下载链接  密码:piv6\n\nStruts2\n开发技巧和整合策略-Struts2       百度云下载链接  密码:htn3\nStruts2 技术内幕——深入解析 Struts2 架构设计与实现原理       百度云下载链接  密码:2mv2\n\nSpring\nSpring 知识点概述       百度云下载链接  密码:1hcq\nSpring 入门指南松哥版       百度云下载链接  密码:zvob\nSpring 技术手册       百度云下载链接  密码:ox17\nSpring 揭秘       百度云下载链接  密码:4lj7\nSpring 实战       百度云下载链接  密码:lw0b\n\nNetty\nNetty 进阶之路 跟着案例学       百度云下载链接  密码:iwij\nNetty 权威指南       百度云下载链接  密码:4n6n\nNetty 实战       百度云下载链接  密码:gy3p\n\n数据库SQL\nHead First SQL       百度云下载链接  密码:u979\nSQL 必知必会       百度云下载链接  密码:qv4z\nSQL 学习指南       百度云下载链接  密码:hdf0\n\nMySQL\nMySQL 必知必会       百度云下载链接  密码:q9cu\n深入浅出MySQL       百度云下载链接  密码:ri07\nMySQL 技术内幕 innodb 存储引擎       百度云下载链接  密码:uetn\nMySQL 技术内幕 SQL 编程       百度云下载链接  密码:wxzb\nMySQL 性能调优与架构设计       百度云下载链接  密码:1464\n高性能 MySQL       百度云下载链接  密码:bxrk\n\nRedis\nRedis 入门指南       百度云下载链接  密码:e2sk\nRedis 设计与实现       百度云下载链接  密码:spsz\nRedis 深度历险：核心原理与应用实践       百度云下载链接  密码:uzwc\nRedis 实战       百度云下载链接  密码:otjw\nRedis 入门指南松哥版       百度云下载链接  密码:iuj9\nRedis 源代码分析       百度云下载链接  密码:8q33\n\nMongoDB\nMongoDB 权威指南       百度云下载链接  密码:zivs\n\nMongoDB实战(第二版)       百度云下载链接  密码:bhxe\n\n数据库系统基础教程       百度云下载链接  密码:nmee\n\n自己动手设计数据库       百度云下载链接  密码:tj8g\n\nSQL+Server+2008 实战       百度云下载链接  密码:5m2v\n\n\n并发编程\nJava 并发编程之美       百度云下载链接  密码:hrgi\n精通 Java 并发编程       百度云下载链接  密码:ld0w\n深入浅出 Java 多线程       百度云下载链接  密码:drjx\n实战 Java 高并发程序设计       百度云下载链接  密码:usiw\nJava 并发编程实战       百度云下载链接  密码:r0ay\nJava 并发编程的艺术       百度云下载链接  密码:x8b7\nJava 多线程编程实战指南       百度云下载链接  密码:v31b\n\n底层\n深入理解 Java 虚拟机-周志明       百度云下载链接  密码:ke1i\n深入理解 Java 虚拟机总结       百度云下载链接  密码:ixev\n深入理解 Java 内存模型       百度云下载链接  密码:k3c6\n实战 Java 虚拟机 JVM 故障诊断与性能优化       百度云下载链接  密码:jzd7\nJava JDK 学习笔记       百度云下载链接  密码:9o05\n\n性能优化\n修改代码的艺术       百度云下载链接  密码:eg5x\n编写高质量代码：改善 Java 程序的 151 个建议       百度云下载链接  密码:hlnn\n代码整洁之道       百度云下载链接  密码:ghyd\n代码之美精选版       百度云下载链接  密码:zlxp\n码出高效：Java 开发手册       百度云下载链接  密码:uiok\n嵩山版阿里巴巴 Java 开发手册       百度云下载链接  密码:pplh\n重构       百度云下载链接  密码:ksqr\nEffective Java       百度云下载链接  密码:y6ur\nJava 程序性能优化       百度云下载链接  密码:b8w7\nJava 程序员修炼之道       百度云下载链接  密码:wvx1\nJava 工程师修炼之道       百度云下载链接  密码:gmlu\nJava 性能权威指南       百度云下载链接  密码:0av5\nJVM 性能优化       百度云下载链接  密码:enbu\nTomcat 性能优化       百度云下载链接  密码:388n\nOracle 性能优化求生指南       百度云下载链接  密码:bcgd\nMySQL 性能优化的 21 个最佳实践       百度云下载链接  密码:ex1h\n\n设计模式\n23 种设计模式知识要点       百度云下载链接  密码:w55h\n大话设计模式       百度云下载链接  密码:909m\n设计模式：可复用面向对象软件的基础       百度云下载链接  密码:rdgw\n设计模式之禅       百度云下载链接  密码:x0wx\n深入浅出设计模式       百度云下载链接  密码:yuvv\n Head First 设计模式       百度云下载链接  密码:gkn5\n\n操作系统\n深入理解计算机系统       百度云下载链接  密码:819r\nLinux 与 Unix shell 编程指南       百度云下载链接  密码:z79w\n操作系统原理       百度云下载链接  密码:4llf\n操作系统之哲学原理       百度云下载链接  密码:0jj6\n程序是怎样跑起来的       百度云下载链接  密码:wa9c\n计算机是怎样跑起来的       百度云下载链接  密码:mnvn\n认识操作系统       百度云下载链接  密码:2sm9\nWindows 内核原理与实现       百度云下载链接  密码:lpv9\n现代操作系统原书       百度云下载链接 提取码:7673\n计算机系统概论       百度云下载链接  密码:xudx\n\nLinux基础知识\n鸟哥的 Linux 私房菜       百度云下载链接  密码:yzsl\n循序渐进Linux（第2版）       百度云下载链接  密码:tney\nLinux 程序设计       百度云下载链接  密码:cems\nLinux 命令行与 shell 脚本编程大全       百度云下载链接  密码:tr5u\n\nLinux环境编程\nLinux-Unix 系统编程手册       百度云下载链接  密码:7i9n\nLinux 高性能服务器编程       百度云下载链接  密码:xupv\nUnix 环境高级编程       百度云下载链接  密码:6d05\n\nLinux内核\n深入理解 Linux 内核       百度云下载链接  密码:imav\n深入 Linux 内核架构       百度云下载链接  密码:vnhj\n Linux 内核源代码情景分析       百度云下载链接  密码:o08i\n\n计算机网络\n计算机网络-自顶向下方法       百度云下载链接  密码:d3tj\n图解 HTTP       百度云下载链接  密码:45aw\n图解 TCP IP       百度云下载链接  密码:2qe9\n网络是怎样连接的       百度云下载链接  密码:p8l7\nHTTP 超全混总       百度云下载链接  密码:412z\nJava2 网络协议内幕       百度云下载链接  密码:pwml\nTCPIP 详解       百度云下载链接  密码:q7cg\nTCP IP 网络编程       百度云下载链接  密码:vrlt\nHTTP权威指南       百度云下载链接  密码:o0gn\n\nLinux网络编程\nLinux 多线程服务端编程       百度云下载链接  密码:2rp4\nUnix 网络编程       百度云下载链接  密码:6c3l\n深入理解 Linux 网络技术内幕       百度云下载链接  密码:xrjs\n\nwireshark\nWireshark数据包分析实战       百度云下载链接  密码:by6w\nWireshark网络分析的艺术       百度云下载链接  密码:12h5\nWireshark网络分析就这么简单       百度云下载链接  密码:166d\n\n数据结构与算法\n啊哈算法       百度云下载链接  密码:txid\n编程珠玑       百度云下载链接  密码:2tv6\n编程珠玑续       百度云下载链接  密码:me0y\n大话数据结构       百度云下载链接  密码:i70v\n趣学算法       百度云下载链接  密码:qv4y\n数据结构与算法分析-Java 描述       百度云下载链接  密码:b0l2\n数字图像处理-Java 语言算法描述       百度云下载链接  密码:7v5n\n算法       百度云下载链接  密码:9m6f\n算法导论       百度云下载链接  密码:n4fn\n算法图解       百度云下载链接  密码:685s\nJava 常用算法       百度云下载链接  密码:ybvr\nJava 数据结构和算法       百度云下载链接  密码:qupj\nBAT LeetCode 刷题手册       百度云下载链接  密码:8w3m\n\n面试\n2020年字节跳动Java 工程师面试题       百度云下载链接  密码:iozq\nGoogle 师兄的刷题笔记       百度云下载链接  密码:5ttz\nBAT面试常问80题       百度云下载链接  密码:c54x\n一线互联网企业面试题       百度云下载链接  密码:wjrr\n编程之美       百度云下载链接  密码:ng5q\n程序员面试宝典       百度云下载链接  密码:6rr8\n剑指Offer：名企面试官精讲典型编程题       百度云下载链接  密码:lbsn\n程序员代码面试指南 IT名企算法与数据结构题目最优解       百度云下载链接  密码:0djm\n如何刷力扣       百度云下载链接  密码:h14s\n力扣最优解       百度云下载链接  密码:o28k\n2020最新Java面试题资料       百度云下载链接  密码:mlf8\n最新Java程序员面试宝典       百度云下载链接  密码:u5gh\nJavaGuide 面试突击       百度云下载链接  密码:e0p4\nJava 核心面试知识整理       百度云下载链接  密码:387r\nJava面试题以及答案       百度云下载链接  密码:y4ef\n面试必问之jvm与性能优化       百度云下载链接  密码:y6iu\nSpring 面试题       百度云下载链接  密码:77ud\nDubbo 面试题       百度云下载链接  密码:cl5a\n简历模板与优化       百度云下载链接  密码:1cb0\n\n大数据\n大数据-涂子沛       百度云下载链接  密码:xhym\n数据之巅-涂子沛       百度云下载链接  密码:gb3t\nKafaka 权威指南       百度云下载链接  密码:xb4p\nSpark 快速大数据分析       百度云下载链接  密码:d9qx\nSpark 快速数据处理       百度云下载链接  密码:xvug\nHadoop 权威指南       百度云下载链接  密码:wh8m\nHadoop 技术内幕       百度云下载链接  密码:c945\n\n架构\n大型网站技术架构 核心原理与案例分析       百度云下载链接  密码:r5k1\n高性能高并发服务器架构       百度云下载链接  密码:ofa1\n架构风格与基于网络的软件架构设计       百度云下载链接  密码:a0lf\n架构之美       百度云下载链接  密码:lfxq\n大型网站系统与 Java 中间件实践       百度云下载链接  密码:tboh\n亿级流量网站架构核心技术       百度云下载链接  密码:fwer\n\n扩展其他语言C\nC程序设计语言（第二版，中文版，B.W.Kernighan、D.M.Ritchie 著）       百度云下载链接  密码:bzj8\nC Primer Plus       百度云下载链接  密码:7qru\nC 和指针       百度云下载链接  密码:oaum\nC 陷阱与缺陷       百度云下载链接  密码:diao\nC 专家编程       百度云下载链接  密码:ipzt\n深度探索 C 对象模型       百度云下载链接  密码:z6vp\n数据结构与算法分析——C 语言描述       百度云下载链接  密码:k7kj\n\nC++\n牛客校招面试题（附答案与解析）c++篇       百度云下载链接  密码:h7im\nC++ 面试题库       百度云下载链接  密码:qhrg\n大规模 C++程序设计       百度云下载链接  密码:llij\n深度探索C++对象模型       百度云下载链接  密码:l9l3\n深入理解c11新特性解析与应用       百度云下载链接  密码:g7st\nC++ Primer       百度云下载链接  密码:ehzj\nC++标准程序库—自修教程与参考手册       百度云下载链接  密码:bdv2\nC++性能优化指南       百度云下载链接  密码:h94d\nC++语言的设计和演化       百度云下载链接  密码:3yx1\nEffective.Modern.C++        百度云下载链接  密码:58u1\nEffective+STL中文版：50条有效使用STL的经验       百度云下载链接  密码:em3y\nEffectiveC++中文版（第三版）       百度云下载链接  密码:cu9o\nMore Effective C++中文       百度云下载链接  密码:xlvw\nSTL源码剖析–侯捷       百度云下载链接  密码:pc9e\n\nJavaScript\nJavaScript王者归来       百度云下载链接  密码:xz1j\n超实用的JavaScript代码段       百度云下载链接  密码:s5bz\n单页Web应用  JavaScript从前端到后端       百度云下载链接  密码:dm3c\n你不知道的JavaScript       百度云下载链接  密码:z7il\n实战ES2015深入JavaScript现代应用开发       百度云下载链接  密码:aigg\n数据结构与算法JavaScript描述       百度云下载链接  密码:dt4g\nES6深入浅出       百度云下载链接  密码:06ic\nJavaScript DOM编程艺术       百度云下载链接  密码:9ke7\nJavaScript.DOM高级程序设计       百度云下载链接  密码:ug61\nJavaScript宝典(第6版)       百度云下载链接  密码:lotv\nJavaScript编程全解       百度云下载链接  密码:39ee\nJavaScript从入门到精通       百度云下载链接  密码:awbd\nJavaScript高级程序设计(第2版)       百度云下载链接  密码:pvkw\nJavaScript捷径教程       百度云下载链接  密码:yzs8\nJavaScript框架高级编程       百度云下载链接  密码:glh3\nJavascript框架设计       百度云下载链接  密码:rk3a\nJavaScript面向对象编程指南       百度云下载链接  密码:g63p\nJavaScript启示录       百度云下载链接  密码:20r5\nJavaScript权威指南第六版       百度云下载链接  密码:3j90\nJavaScript入门经典(第3版)       百度云下载链接  密码:g9xm\nJAVASCRIPT设计模式       百度云下载链接  密码:7xvl\nppk谈JavaScript       百度云下载链接  密码:99q9\nJavaScript语言精髓与编程实践       百度云下载链接  密码:omr4\nJavaScript语言精粹       百度云下载链接  密码:h347\nJavaScript 异步编程       百度云下载链接  密码:xeab\nJavaScript 开发技术大全       百度云下载链接  密码:5tdd\n\nPython\nPython+Cookbook第三版中文v2.0.0       百度云下载链接  密码:y68v\n编程小白的第一本Python入门书       百度云下载链接  密码:n8d8\n可爱的Python_中文版       百度云下载链接  密码:o6cf\n利用Python进行数据分析       百度云下载链接  密码:08zf\n深入浅出：使用Python编程       百度云下载链接  密码:vyya\n用Python进行自然语言处理       百度云下载链接  密码:0sx5\nPython高性能编程       百度云下载链接  密码:j4js\nPython编程：从入门到实践       百度云下载链接  密码:rchj\nPython+Web开发：测试驱动方法       百度云下载链接  密码:pfmk\npython-basic       百度云下载链接  密码:te3f\nbyte-of-python-chinese-edition       百度云下载链接  密码:uzip\nPython基础教程(第2版)       百度云下载链接  密码:r8qx\nPython进阶-v1.1       百度云下载链接  密码:x6tf\nPython核心编程(第二版)       百度云下载链接  密码:4nkr\nPython最佳实践指南（中）       百度云下载链接  密码:aldu\nPYTHON自然语言处理【中文版】       百度云下载链接  密码:3tgu\nPython源码剖析（陈儒-2008-电子工业出版）       百度云下载链接  密码:s81x\nPython网络数据采集       百度云下载链接  密码:7x8s\n流畅的 Python       百度云下载链接  密码:ssjd\n\ngo\n学习 go 语言       百度云下载链接  密码:grvq\ngo 语言编程       百度云下载链接  密码:131i\n\nJavaWeb\nJAVA EE WEB开发实例精解       百度云下载链接  密码:m7l0\nJava Web入门经典       百度云下载链接  密码:m8x5\nJava Web设计模式之道       百度云下载链接  密码:khgy\nJava_Web轻量级开发全体验       百度云下载链接  密码:9x7q\nJava.Web开发学习手册       百度云下载链接  密码:lxu8\n\nJSP\nJSP 程序设计       百度云下载链接  密码:o8im\nJSP 技术手册       百度云下载链接  密码:a6pw\nJSP 应用开发详解       百度云下载链接  密码:7myk\nServlet 和 JSP 学习指南       百度云下载链接  密码:mdqy\n\nKotlin\nkotlin-in-chinese       百度云下载链接  密码:53om\nkotlin-for-android-developers-zh       百度云下载链接  密码:m9nz\n\ngroovy\ngroovy 程序设计       百度云下载链接  密码:xmjl\n\nDDD\n领域驱动设计.软件核心复杂性应对之道       百度云下载链接  密码:yc7f\n领域驱动设计精简版       百度云下载链接  密码:9e3x\n\n区块链人工智能\n机器学习与实战       百度云下载链接  密码:buvz\n\n搜索引擎\n开发自己的搜索引擎–Lucene+Heritrix       百度云下载链接  密码:h1oi\nSolrJ教程       百度云下载链接  密码:p0s6\nElasticsearch 权威指南       百度云下载链接  密码:9m8e\nElasticsearch 技术解析与实战       百度云下载链接  密码:yg98\n\n网络安全\nJava 加密与解密的艺术       百度云下载链接  密码:1kgn\n\n消息队列\nRabbitMQ实战 高效部署分布式消息队列       百度云下载链接  密码:26s7\n\n云计算\n大话云计算       百度云下载链接  密码:efwj\n\nAR&amp;VRDocker\n第一本Docker书       百度云下载链接  密码:7dz6\nDocker入门指南松哥版       百度云下载链接  密码:q175\nSpring Cloud与Docker微服务架构实战       百度云下载链接  密码:yeem\n\nIoTKubernets\nKUBERNETES权威指南  从DOCKET到KURBERNETES实践全接触       百度云下载链接  密码:njo1\n\n测试\n有效的单元测试       百度云下载链接  密码:kbc4\n\n管理\n人月神话       百度云下载链接  密码:ctf3\n人件       百度云下载链接  密码:39iz\n微管理：给你一个技术团队，你该怎么管（全彩）       百度云下载链接  密码:u6ml\n\n加餐\n编程人生       百度云下载链接  密码:mmba\n程序员修炼之道：从小工到专家       百度云下载链接  密码:7yle\n代码大全       百度云下载链接  密码:geyj\n黑客与画家       百度云下载链接  密码:eyzn\n奇思妙想：15 位计算机天才及其重大发现       百度云下载链接  密码:fm21\n图灵的秘密       百度云下载链接  密码:oa92\n我编程我快乐       百度云下载链接  密码:tqnx\n《阿里技术参考图册》（算法篇）       百度云下载链接  密码:4eev\n《阿里技术参考图册》（研发篇）       百度云下载链接  密码:hq1u\n程序员必知的硬核知识大全       百度云下载链接  密码:dp1p\nhow-to-be-a-programmer-cn       百度云下载链接  密码:kar9\n卓有成效的程序员       百度云下载链接  密码:6511\n程序员的职业素养       百度云下载链接  密码:n2zg\n程序员内功修炼-V2.0       百度云下载链接  密码:xmg5\n设计原本（中文版）       百度云下载链接  密码:zaxe\n数学之美       百度云下载链接  密码:mbmh\n淘宝技术这十年       百度云下载链接  密码:b4u6\n如何变得有思想  阮一峰博客文集       百度云下载链接  密码:7yyh\n沉默的大多数       百度云下载链接  密码:6vcc\n香帅北大金融学课 线下大课       百度云下载链接  密码:cfcm\n学习学习再学习       百度云下载链接  密码:vup6\n学习正则表达式       百度云下载链接  密码:icft\n自己动手写网络爬虫       百度云下载链接  密码:cz9n\nCh3-Ch5-超人气博客是怎样炼成的       百度云下载链接  密码:34v0\n深入理解Nginx：模块开发与架构解析-陶辉       百度云下载链接  密码:k9zc\n深入剖析Tomcat-高清-书签       百度云下载链接  密码:o77f\nWEB服务_原理与技术       百度云下载链接  密码:gvoc\n由浅入深学Java—基础、进阶与必做260题       百度云下载链接  密码:r1tk\nJava与模式       百度云下载链接  密码:56lw\nJava游戏高级编程       百度云下载链接  密码:mp4i\nJava应用架构设计 模块化模式与OSGi       百度云下载链接  密码:vgm6\nJava典型模块与项目实战大全       百度云下载链接  密码:svgn\n\n活着\n程序员健康指南       百度云下载链接  密码:pl0i\n颈椎康复指南       百度云下载链接  密码:ouhh\n\n免责声明书籍全部来源于网络其他人的整理，我这里只是收集整理了他们的链接，如有侵权，马上联系我，我立马删除对应链接。我的邮箱：&#x39;&#x38;&#x33;&#x34;&#51;&#x36;&#48;&#55;&#54;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;\n","tags":["教程"]},{"title":"关于男魂符号（♂）","url":"/2021/08/03/MaleSoul/","content":"\n哲学引♂导人民\n\n关于男魂符号（♂）“♂”男性代表符号，哲♂学中通称男魂，使用方法有语气增强、形容词、助词、特殊意义动词（读起来更哲♂学)。 在输入法中打“nan”就可以看到（有时需要打“nanxing”才可以看到），部分输入法需在特殊符号处来输入（多为较低版本的输入法）\n使用方法示例\n\n博丽灵梦这样的站姿真是太哲♂学了”在这里，男魂是对于哲♂学加以形容，如果没有男魂很容易产生歧义，也就是更加容易让人想歪。通常用于一些有多种含义的词汇。(当然，如果不明白哲♂学的也看不懂说白了就是黑话)\n\n“贝奥兰迪使用了奥义·双重♂雪步”男魂在这句话中其实没什么意义，只是单纯增强语气。由于双重雪步已经属于哲♂学内部用语，所以增加男魂就是语气增强。当然并不是非得插♂入使用，也可以这样 ——♂双重雪步♂，不过效果看起来欠佳罢了，无标准用法。\n\n“比利海灵顿使用了无双♂大王，压制了城之内悠二♂♂♂”这种用法极为少见，属于无意义助词，必须配合实际情况使用。\n\n“木吉和也”与“木吉♂和也”其实意义相同，然而第二种看着不是更加哲♂学一点么不是？不常用。\n\n“真是一场惊天动地的炒♂饭”炒饭属于哲♂学用语，类别为动词，但容易产生歧义，加上男魂就一目了然了（其实与1用法相同不过一般夹在动词中）。举个最常见的例子——“摔跤”和“摔♂跤”，还用多解♂释么？\n\n\n特殊用法这里就要提到雌魂“♀”了。主要用法大部分同男魂“♂”，但由于没有公认的“王（♀）”所以大多数哲♀学家使用时只限于百合一类。Saber♀\n有时也是“污”的代名词，举例：好想有一个能♂干的妹妹♀\n错误用法\n请注意，男魂本身没有错误用法，男魂的使用没有明确的禁项。怒涛男魂指的是在语句里胡乱使用男魂导致语句被分割的不成样子，在哲♂学的发源地，N站其实是没有关于男魂使用的规矩的。在哲♂学传入中国后，很多对哲♂学了解不够深刻的人为了展现哲♂学家的身份便在一句话中加很多男魂，于是兄贵吧的吧务为了防止影响阅读、希望更多人了解哲♂学而非专注于在说话时加男魂便设立吧规禁止一句话超过三个男魂（现已取消）。这使很多人以为一句话超过三个男魂违反了哲♂学教义，但实际上男魂并没有数量的限制，所以并不是一句话超过三个男魂就是怒涛。不过加太多男魂甚至每个字都加男魂是可能误导新人并且影响阅读的使用方法。\n\n过多的男魂会导致视频或文章的观看体验受到影响，也会引起哲♂学家们的反感。如果你用的准用的好，用多少都无所谓。不过一般一句话里的确没那么多地方让你加男魂。那些在一般兄贵视频下面刷“卧♂槽♂是♂比♂利♂海♂林♂顿♂”之类的弹幕与评论都是故意让你回复他“怒涛炸裂”的大多都是#小鬼，请自己明白并不要给予理会，如此才能减少这种现象。希望诸位哲学家怀着许容の心，宽容对待后辈，积极教导后辈，这样才能真正的理解哲♂学。\n","tags":["哲♂学"]},{"title":"Python 调用 HTTP API 接口模板","url":"/2021/08/09/PythonHttpAPI/","content":"搜索引擎上获取的代码大多鱼龙混杂，因此自己写一个保存以待后用\n#!/usr/bin/env python# -*- coding:utf-8 -*-#@Time  : 2021/8/9 20:30#@Author: f#@File  : main.pyimport requestsdef sendPost(param1,param2):        base_url = &#x27;http://url/&#x27;    data =&#123;        &#x27;param1&#x27;:param1,        &#x27;param2&#x27;:param2    &#125;    headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)&#x27;,        &#x27;Accept&#x27;: &#x27;text/html, application/xhtml+xml, */*&#x27;    &#125;        session = requests.session()    response = session.post(base_url, data=data,headers=headers, verify=False)        print(response.text)if __name__ == &#x27;__main__&#x27;:    param1=&#x27;param1&#x27;    param2=&#x27;param2&#x27;    sendPost(param1,param2)\n","tags":["开发"]},{"title":"通俗地解释脏读、不可重复读、幻读","url":"/2021/08/24/Serializable/","content":"1.数据库 事务隔离级别分为四种（级别递减）：Serializable （串行化）：顾名思义，可串行化的，也即并发事务串行执行。很显然，该级别可以避免前面讲到的所有问题：“脏读”、“不可重复读”和“幻读”。代价是处理事务的吞吐量低，严重浪费数据库的性能，因此要慎用此事务隔离级别。\n最严格的级别，事务串行执行，资源消耗最大；\n下面演示Serializable如何解决这些问题：\n1. 小明连接数据库去查询自己本学期的成绩，他设置session(当前连接)的事务隔离级别为Serializable：\nxiaoming&gt; set session transaction isolation level serializable;Query OK, 0 rows affected (0.00 sec) xiaoming&gt; select @@tx_isolation;+----------------+| @@tx_isolation |+----------------+| SERIALIZABLE   |+----------------+1 row in set (0.00 sec)\n\n2. 小明开始查询成绩，由于还没有录入，因此没有成绩：\nxiaoming&gt; begin;Query OK, 0 rows affected (0.00 sec) xiaoming select * from scores where name = &#x27;xiaoming&#x27;;Empty set (0.00 sec)\n\n3. 这时小明的班主任王老师也连接数据库来录入成绩，可是他会卡在插入第一条成绩信息这里, 如下所示，insert语句迟迟不会返回：\nmr.wang&gt; begin;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; insert into scores(name, score) values (&#x27;xiaoming&#x27;, 69);\n\n4. 小明结束本次查询：\nxiaoming&gt; commit;Query OK, 0 rows affected (0.00 sec)\n\n5. 这时王老师插入第一条成绩才完成：\nmr.wang&gt; insert into scores(name, score) values (&#x27;xiaoming&#x27;, 69);Query OK, 1 row affected (3.42 sec)\n\n6. 如果小明久久不结束查询，还会导致王老师录入成绩超时：\nxiaoming&gt; insert into scores(name, score) values (&#x27;xiaoming&#x27;, 69);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n\n从上面的例子我们可以看出，如果一个session设置隔离级别为Serializable时，其执行事务时会阻塞其他并发事务，从上面的错误信息中我们也可以看出应该是通过某种锁来实现的。既然是这样，那么“脏读”、“不可重复读”和“幻读”自然是不可能发生了。\nREPEATABLE READ（重复读） ：也即在一个事务范围内相同的查询会返回相同的数据，保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。延续上面的栗子：\n1. 小明很开心自己考了69分，于是他连接到数据库查询自己的成绩来炫耀给小伙伴，由于Repeatable Read是默认的事务隔离级别，因此这次他不需要进行修改：\nxiaoming&gt; select @@tx_isolation;+-----------------+| @@tx_isolation  |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.00 sec) xiaoming&gt; begin;Query OK, 0 rows affected (0.00 sec) xiaoming&gt; select * from scores where name = &#x27;xiaoming&#x27;;+----+----------+-------+| id | name     | score |+----+----------+-------+|  1 | xiaoming |    69 |+----+----------+-------+1 row in set (0.00 sec)\n\n2. 不幸的是，小明的班主任王老师复查试卷后，发现小明的成绩多加了10分，于是他连接到数据库来修改小明的成绩：\nmr.wang&gt; begin;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; update scores set score = 59 where name = &#x27;xiaoming&#x27;;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0 mr.wang&gt; commit;Query OK, 0 rows affected (0.00 sec)\n\n3. 接着小明觉得还不尽兴，于是又查一次，还是69分，可怜的是他不知道自己其实是不及格的：\nxiaoming&gt; select * from scores where name = &#x27;xiaoming&#x27;;+----+----------+-------+| id | name     | score |+----+----------+-------+|  1 | xiaoming |    69 |+----+----------+-------+1 row in set (0.00 sec)\n\n可见Repeatable Read的确可以解决“不可重复读”的问题，小明在一次事务中2次查询的成绩都是一样的，即使2次查询中王老师修改了成绩。注意我们演示的场景中，王老师是针对一条已有的记录进行了Update， 如果王老师是新增即Insert小明的成绩，那么小明的2次查询的结果还是不一样的，如下所示：\n1.首先小明第一次查询, 没有成绩\nxiaoming&gt; select * from scores where name = &#x27;xiaoming&#x27;;Empty set (0.00 sec)\n\n2. 然后王老师录入成绩\nmr.wang&gt; begin;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; insert into scores(name,score) values (&quot;xiaoming&quot;, 59);Query OK, 1 row affected (0.00 sec) mr.wang&gt; commit;Query OK, 0 rows affected (0.00 sec)\n\n3. 最后小明再次查询成绩，这次有了：\nxiaoming&gt; select * from scores where name = &#x27;xiaoming&#x27;;+----+----------+-------+| id | name     | score |+----+----------+-------+|  1 | xiaoming |    59 |+----+----------+-------+1 row in set (0.00 sec)\n\n通过上述例子，我们可以看出Repeatable Read也是存在以下问题的：\na. 幻读，也即在一次事务范围内多次进行查询，如果其他并发事务中途插入了新的记录，那么之后的查询会读取到这些“幻影”行。\n另外，我们也需要注意，不可重复读对应的是修改即Update，幻读对应的是插入即Insert。\nREAD COMMITTED （提交读）：顾名思义，就是读已提交，一个事务只能看到其他并发的已提交事务所作的修改，是大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。\n下面通过例子来演示Read Committed解决“脏读”：\n1. 小明连接数据库去查询自己本学期的成绩，他设置session(当前连接)的事务隔离级别为Read Committed：\nxiaoming&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec) xiaoming&gt; select @@tx_isolation;+----------------+| @@tx_isolation |+----------------+| READ-COMMITTED |+----------------+1 row in set (0.00 sec)\n\n2. 就在这个时候，小明的班主任王老师也连接了数据库去登记学生本学期的成绩：\nmr.wang&gt; begin;  Query OK, 0 rows affected (0.00 sec)    mr.wang&gt; insert into scores(name,score) values (&quot;xiaoming&quot;, 59);  Query OK, 1 row affected (0.00 sec)  \n\n3. 当王老师还没有提交事务时，小明刚好开始查询自己的成绩，结果他没查到成绩，因为王老师还没提交：\nxiaoming&gt; begin;Query OK, 0 rows affected (0.00 sec) xiaoming&gt; select * from scores where name = &#x27;xiaoming&#x27;;  Empty set (0.00 sec)\n\n4. 小明查成绩之后，王老师发现自己登错了成绩，其实小明考了69分，于是他回滚了当前事务, 并重新录入了小明的正确成绩:\nmr.wang&gt; rollback;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; begin;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; insert into scores(name,score) values (&quot;xiaoming&quot;, 69); Query OK, 1 row affected (0.00 sec) mr.wang&gt; commit;Query OK, 0 rows affected (0.00 sec)\n\n5. 接着，小明又查了一次成绩，这次他查到了，他很开心，因为他及格了\nxiaoming&gt; select * from scores where name = &#x27;xiaoming&#x27;;  +----+----------+-------+| id | name     | score |+----+----------+-------+|  1 | xiaoming |    69 |+----+----------+-------+1 row in set (0.00 sec)\n\n虽然解决了“脏读”问题，但是Read Committed不能保证在一个事务中每次读都能读到相同的数据，因为在每次读数据之后其他并发事务可能会对刚才读到的数据进行修改。就像上面，小明在一次事务中2次读取成绩返回的结果不一样。这也反映出了Read Committed事务隔离级别存在以下问题：\na. 不可重复读， 也即一个事务范围内两个相同的查询却返回了不同数据\nRead Uncommitted（未提交读） ：顾名思义，就是读未提交，也就是说事务所作的修改在未提交前，其他并发事务是可以读到的。\n事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。\n1. 假设现在有个学生小明连接到数据库去读取自己本学期的成绩，它设置session(当前连接)的事务隔离级别为Read Uncommitted：\nxiaoming&gt; select @@tx_isolation;+-----------------+| @@tx_isolation  |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.00 sec) xiaoming&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec) xiaoming&gt; select @@tx_isolation;+------------------+| @@tx_isolation   |+------------------+| READ-UNCOMMITTED |+------------------+1 row in set (0.00 sec)\n\n2. 就在这个时候，小明的班主任王老师也连接了数据库去登记学生本学期的成绩：\nmr.wang&gt; begin;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; insert into scores(name,score) values (&quot;xiaoming&quot;, 59);Query OK, 1 row affected (0.00 sec)\n\n3. 当王老师还没有提交事务时，小明刚好开始查询自己的成绩，结果他查到自己考了59分，他伤心的要死：\nxiaoming&gt; begin;Query OK, 0 rows affected (0.00 sec) xiaoming&gt; select * from scores where name = &#x27;xiaoming&#x27;;+----+----------+-------+| id | name     | score |+----+----------+-------+|  1 | xiaoming |    59 |+----+----------+-------+1 row in set (0.00 sec)\n\n4. 小明查成绩之后，王老师发现自己登错了成绩，其实小明考了69分，于是他回滚了当前事务, 并重新录入了小明的正确成绩:\nmr.wang&gt; rollback;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; begin;Query OK, 0 rows affected (0.00 sec) mr.wang&gt; insert into scores(name,score) values (&quot;xiaoming&quot;, 69);Query OK, 1 row affected (0.00 sec) mr.wang&gt; commit;Query OK, 0 rows affected (0.00 sec)\n\n5. 小明也没有复查成绩，因此整个寒假都过的很不开心，毕竟自己没有”及格”！\n通过上述场景，我们发现，Read Uncommitted这个最低的事务隔离级别存在以下这些问题：\na. 允许脏读(dirty reads)，就像上面王老师录入的错误成绩(脏数据)被小明读到一样\n2.脏读、不可重复读、幻读：也许有很多读者会对上述隔离级别中提及到的 脏读、不可重复读、幻读 的理解有点吃力，我在这里尝试使用通俗的方式来解释这三种语义：\n脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。\n也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。\n不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。\n也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。\n幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。\n也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。\n","tags":["开发"]},{"title":"TeamSpeak快速帮助","url":"/2021/08/03/TeamSpeak%E5%BF%AB%E9%80%9F%E5%B8%AE%E5%8A%A9/","content":"TeamSpeak快速帮助：TeamSpeak资源下载\n这里给两个下载地址：\n\nhttps://wwa.lanzoui.com/ilq7Es5231e TeamSpeak中文绿色版，不需要安装，开箱即用\nhttps://wwa.lanzoui.com/iMYHls52alg安装版，需要走一遍安装流程建议有功夫的话使用安装版  \n俺的Teamspeak地址：IP：快速连接121.89.218.85或者是域名 记忆ts.xrervip.tk  \n\n快速连接点我快速连接到121.89.218.85如果没有安装请点击\n使用方法下载下面来说说使用方法，此处会从安装开始说起，以方便新用户进行使用。建议不要使用某国内公司制作的中文翻译版ts1.cn，该版本过旧，无法登陆现有的大部分 TeamSpeak 服务器\n第一步，下载 TeamSpeak 此处可以前往 TeamSpeak 官网 teamspeak.com 进行下载，也可以通过转存蓝奏云地址进行下载，解决国内在官网下载速度过慢的问题这里给两个下载地址：\n\nhttps://wwa.lanzoui.com/ilq7Es5231e TeamSpeak中文绿色版，不需要安装，开箱即用\nhttps://wwa.lanzoui.com/iMYHls52alg安装版，需要走一遍安装流程建议有功夫的话使用安装版ps：安装版可能需要中文语音包下载地址 https://github.com/jitingcn/TS3-Translation_zh-CN/releases\n\n连接至服务器快速连接点我快速连接到121.89.218.85\n手动连接点击主界面上面的工具栏中 连接(Connect) - 连接，在 服务器域名或地址（Server Nickname or Address） 的位置输入服务器地址（121.89.218.85 或者ts.xrervip.tk），昵称（ Nickname） 位置输入昵称后，点击 连接(Connect) 即可。PS：俺的Teamspeak地址：121.89.218.85\n常见问题如何设置感应麦？（在嘈杂的环境中对队友特别舒适）点击工具栏中的工具(Tools) ，在菜单中打开最下方设置(Options) 菜单目录 ，选择第四栏输入(Capture) 选项卡。可以在右侧的 配置 中看到 语音感应激活(Capture Voice Activation)选项，模式选择 Volume Gate。\n下方的滑杆代表感应灵敏度，您可以通过点击 开始测试(Begin test) 用平时的嗓音进行测试。一般情况下，推荐打开下方数字信号处理的回声抑制(Echo reduction) 回声消除(Echo cancellation) 以及 消除背景噪音，但具体请根据个人情况及设备的不同，自行判断。\n\n感应麦可能出现的问题？ 话别人只能听到后半句 / 录入过多杂音一般此情况为灵敏度配置不当导致的。通过调节语音感应激活中提到的滑杆，滑杆越往左越灵敏，不断地测试，找到适合自己的灵敏度即可解决此问题。\n内容抄袭自https://ts.wevg.org/why-teamspeak/\n\n\n\n\n     (adsbygoogle = window.adsbygoogle || []).push({});\n","tags":["工具"]},{"title":"向世界传达这梦想与自由","url":"/2021/08/02/banana/","content":"\n  \n\n  \n  \n镜头前，一个男人在舞蹈着。\n他身上并没有多少衣物，一个红色头巾，一个遮住关键部位的短裤。\n他舞蹈着。\n但是仔细看，会觉得这个舞蹈缺少了什么。\n是什么呢？\n他的动作……似乎有些拘束。\n但这也能理解。毕竟，一个男人衣着寸缕，在镜头前……\n但这样的舞蹈是没有灵魂的。\n他似乎也意识到了这个问题，尽力地想要克服这种拘束。\n却总是差那么一步。\n我到底在干什么啊？他很迷茫。\n突然，一个低头的动作，让他愣住了。\n短裤上，印着美利坚的国旗。\n他不禁想到了自己的初衷。\n他的初衷……\n那天，他走在街上。\n他看着来往的人们，\n有些压抑。\n这些人们，都是面无表情，行色匆匆。\n他们被拘束了。\n他们缺少自由。\n于是，他决定，\n要改变这个世界，\n让这个世界，这些人们，\n拥有自由。\n他要让美利坚，\n拥有自由！\n他深呼吸，\n身体内的一个闸门似乎被打开了。\n他的动作，变得更加有力量。\n他的表情，更加放荡不羁。\n他的一举一动，都充分地诠释了——\n自由。\n他要通过自己的舞蹈，\n向人们，\n向美利坚，\n乃至整个世界，\n展示着自由，\n证明着自由，\n诠释着自由。\n无论有多少人能理解他的舞蹈，\n他都不在乎。\n因为，这就是自由！\n自由，是没有边界的。\n是没有限制的。\n更没有人们的世俗眼光。\n一段舞蹈结束，\n他的脸上带着微笑。\n因为，他做到了\n他成功了。\n他不知道他的舞蹈会给别人带来什么影响，\n他只知道，\n他享受的仅仅是这个过程。\n这个传递自由的过程。\n他来自美利坚。\n他是那个象征着自由的男人。\n","tags":["哲♂学"]},{"title":"中文文案排版指北","url":"/2021/08/06/chinese-copywriting-guidelines/","content":"中文文案排版指北Other languages:\n\nEnglish\nChinese Traditional\nChinese Simplified\n\n\n目录\n\n\n空格\n中英文之间需要增加空格\n中文与数字之间需要增加空格\n数字与单位之间无需增加空格\n全角标点与其他字符之间不加空格\n-ms-text-autospace to the rescue?\n\n\n标点符号\n不重复使用标点符号\n\n\n全角和半角\n使用全角中文标点\n数字使用半角字符\n遇到完整的英文整句、特殊名词，其內容使用半角标点\n\n\n名词\n专有名词使用正确的大小写\n不要使用不地道的缩写\n\n\n争议\n链接之间增加空格\n简体中文使用直角引号\n\n\n工具\n谁在这样做？\n参考文献\n\n\n\n空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。\n与大家共勉之。」\n中英文之间需要增加空格正确：\n\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。\n\n错误：\n\n在LeanCloud上，数据存储是围绕AVObject进行的。\n\n\n在 LeanCloud上，数据存储是围绕AVObject 进行的。\n\n完整的正确用法：\n\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\n\n例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。\n中文与数字之间需要增加空格正确：\n\n今天出去买菜花了 5000 元。\n\n错误：\n\n今天出去买菜花了 5000元。\n\n\n今天出去买菜花了5000元。\n\n数字与单位之间无需增加空格正确：\n\n我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。\n\n错误：\n\n我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。\n\n另外，度／百分比与数字之间不需要增加空格：\n正确：\n\n今天是 233° 的高温。\n\n\n新 MacBook Pro 有 15% 的 CPU 性能提升。\n\n错误：\n\n今天是 233 ° 的高温。\n\n\n新 MacBook Pro 有 15 % 的 CPU 性能提升。\n\n全角标点与其他字符之间不加空格正确：\n\n刚刚买了一部 iPhone，好开心！\n\n错误：\n\n刚刚买了一部 iPhone ，好开心！\n\n-ms-text-autospace to the rescue?Microsoft 有个 -ms-text-autospace 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。\n标点符号不重复使用标点符号正确：\n\n德国队竟然战胜了巴西队！\n\n\n她竟然对你说「喵」？！\n\n错误：\n\n德国队竟然战胜了巴西队！！\n\n\n德国队竟然战胜了巴西队！！！！！！！！\n\n\n她竟然对你说「喵」？？！！\n\n\n她竟然对你说「喵」？！？！？？！！\n\n全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。\n使用全角中文标点正确：\n\n嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！\n\n\n核磁共振成像（NMRI）是什么原理都不知道？JFGI！\n\n错误：\n\n嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎!\n\n\n嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎!\n\n\n核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!\n\n\n核磁共振成像(NMRI)是什么原理都不知道?JFGI!\n\n数字使用半角字符正确：\n\n这件蛋糕只卖 1000 元。\n\n错误：\n\n这件蛋糕只卖 １０００ 元。\n\n例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。\n遇到完整的英文整句、特殊名词，其內容使用半角标点正确：\n\n乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」\n\n\n推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。\n\n错误：\n\n乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」\n\n\n推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。\n\n名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。\n正确：\n\n使用 GitHub 登录\n\n\n我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。\n\n错误：\n\n使用 github 登录\n\n\n使用 GITHUB 登录\n\n\n使用 Github 登录\n\n\n使用 gitHub 登录\n\n\n使用 gｲんĤЦ8 登录\n\n\n我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n\n我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。\n\n\n我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。\n\n\n我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。\n\n\n我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。\n\n注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。\n不要使用不地道的缩写正确：\n\n我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。\n\n错误：\n\n我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。\n\n争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。\n链接之间增加空格用法：\n\n请 提交一个 issue 并分配给相关同事。\n\n\n访问我们网站的最新动态，请 点击这里 进行订阅！\n\n对比用法：\n\n请提交一个 issue 并分配给相关同事。\n\n\n访问我们网站的最新动态，请点击这里进行订阅！\n\n简体中文使用直角引号用法：\n\n「老师，『有条不紊』的『紊』是什么意思？」\n\n对比用法：\n\n“老师，‘有条不紊’的‘紊’是什么意思？”\n\n工具\n\n\n仓库\n语言\n\n\n\nvinta/paranoid-auto-spacing\nJavaScript\n\n\nhuei90/pangu.node\nNode.js\n\n\nhuacnlee/auto-correct\nRuby\n\n\nsparanoid/space-lover\nPHP (WordPress)\n\n\nnauxliu/auto-correct\nPHP\n\n\nricoa/copywriting-correct\nPHP\n\n\nhotoo/pangu.vim\nVim\n\n\nsparanoid/grunt-auto-spacing\nNode.js (Grunt)\n\n\nhjiang/scripts/add-space-between-latin-and-cjk\nPython\n\n\n谁在这样做？\n\n\n网站\n文案\nUGC\n\n\n\nApple 中国\nYes\nN/A\n\n\nApple 香港\nYes\nN/A\n\n\nApple 台湾\nYes\nN/A\n\n\nMicrosoft 中国\nYes\nN/A\n\n\nMicrosoft 香港\nYes\nN/A\n\n\nMicrosoft 台湾\nYes\nN/A\n\n\nLeanCloud\nYes\nN/A\n\n\n知乎\nYes\n部分用户达成\n\n\nV2EX\nYes\nYes\n\n\nSegmentFault\nYes\n部分用户达成\n\n\nApple4us\nYes\nN/A\n\n\n豌豆荚\nYes\nN/A\n\n\nRuby China\nYes\n标题达成\n\n\nPHPHub\nYes\n标题达成\n\n\n少数派\nYes\nN/A\n\n\n力扣 LeetCode\nYes\nYes\n\n\n参考文献\nGuidelines for Using Capital Letters\nLetter case - Wikipedia\nPunctuation - Oxford Dictionaries\nPunctuation - The Purdue OWL\nHow to Use English Punctuation Corrently - wikiHow\n格式 - openSUSE\n全角和半角 - 维基百科\n引号 - 维基百科\n疑问惊叹号 - 维基百科\n\n\n抄袭自https://github.com/mzlogin/chinese-copywriting-guidelines\n\n","tags":["开发"]},{"title":"欢迎使用teamspeak3","url":"/2021/10/19/invitToTeamspeak3/","content":"\n\n\n\nTeamSpeak 3 Server Invitation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou have been invited to this TeamSpeak 3 Server:\n\n\n    \n    121.89.218.85:9987      \n\n\nURL: ts3server://121.89.218.85\n\n\n\nIf TeamSpeak 3 is installed on your computer, you are now being redirected to the server.If you are not automatically redirected within 5 seconds, please click HERE instead.\n\n\n\n\n\n"},{"title":"使用PowerShell下载文件","url":"/2021/10/02/powershellDownload/","content":"使用PowerShell下载文件\npowershell (new-object System.Net.WebClient).DownloadFile(&#x27;文件的URL&#x27;,&#x27;文件本地存储的地址&#x27;)\n例如\npowershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://121.89.218.85/frp_0.37.1_windows_amd64.zip&#x27;,&#x27;C:\\Users\\Administrator\\frp_0.37.1_windows_amd64.zip&#x27;)\n\n","tags":["教程"]},{"title":"生活在沈阳大街上","url":"/2021/08/03/shenyangstreet/","content":" \n\n\n我是旧时代的残党,新时代没有能承载我的船  \n\n现代咬打火机以fw刀的“网络世界，真真假假假假真真，没有银事不怕屎滴”为嚆矢。滥觞于整活与直播的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循虎弟“你狗屁才艺”好过过早地振翮。\n我们怀揣热忱的灵魂天然被赋予对超越性的追求，不屑于古旧坐标的约束，钟情于在别处的芬芳。但当这种期望流于对快手出道主义不假思索的批判，乃至走向整烂活与恰烂钱主义时，便值得警惕了。与秩序的落差、错位向来不能为越矩的行为张本。而纵然我们已有翔实的蓝图，仍不能自持已在浪潮之巅立下了自己的沉锚。\n“OK！兄弟们，所有目光向我看齐，看我看我，我宣布个事，我是个傻逼！”虎弟之言可谓切中了肯綮。人的满嘴长牙，净唠逼嗑性是不可祓除的，而我们欲上青云也无时无刻不在因风借力。直播与整活暂且被我们把握为一个薄脊的符号客体，一定程度上是因为我们尚缺乏体验与阅历去支撑自己的认知。而这种偏见的傲慢更远在知性的傲慢之上。\n在孜孜矻矻以求咬打火机意义的道路上，对自己的期望本就是在与直播与整活对接中塑型的动态过程。而我们的底料便是对不同唐老鸭上吊、不同头开机油桶的觉感与体认。唐老鸭为小亮送去徒手劈砖头，又维系咬打火机。他的咬打火机观念是厚实的，也是实践的。倘若我们在对过往借fw刀之言“祓魅”后，又对不断膨胀的自我进行“赋魅”，那么在丢失外界预期的同时，未尝也不是丢了自我。\n毫无疑问，从整活与直播角度一觇的自我有偏狭过时的成分。但我们所应摒弃的不是对此的批判，而是其批判的廉价，其对批判投诚中的反智倾向。在虎弟的观念中，如果在成为狮子与孩子之前，略去了像骆驼一样背负前人遗产的过程，那其“永远重复”洵不能成立。\n蓝图上的落差终归只是理念上的区分，在实践场域的分野也未必明晰。譬如当我们追寻跳冰窟窿时，在途中涉足小亮后空翻，这究竟是伴随着期望的泯灭还是期望的达成？在我们塑造咬打火机的同时，咬打火机也在浇铸我们。既不可否认原生的拉跨性与fw性，又承认自己的图景有轻狂的失真，不妨让体验走在言语之前。用不被禁锢的头脑去体味fw刀的大海与风帆，并效百特曼，对无法言说之事保持沉默。\n用在沈阳大街上的生活方式体现个体的超越性，保持婞直却又不拘泥于所谓“遗世独立”的单向度形象。这便是fw刀为我们提供的理想期望范式。生活在沈阳大街上——始终热爱大地——升上天空。 \n","tags":["东百往事"]},{"title":"teamspeak3","url":"/2021/08/02/teamspeak3/","content":"快速获取帮助：TeamSpeak资源下载这里给两个下载地址：\n\nhttps://wwa.lanzoui.com/ilq7Es5231e TeamSpeak中文绿色版，不需要安装，开箱即用\nhttps://wwa.lanzoui.com/iMYHls52alg安装版，需要走一遍安装流程建议有功夫的话使用安装版  \n俺的Teamspeak地址：121.89.218.85\n\n什么是 TeamSpeakTeamSpeak (简称TS) 是一套专有的VoIP软件，使用者可以用耳机和麦克风，通过客户端软件连线到指定的服务器，与在服务器内频道的其他使用者进行通话。是一种很像电话会议的方式。 通常 TeamSpeak 的使用者大多为多人连线游戏的玩家，与同队伍的玩家进行通讯。在游戏的对战方面，语音对话通讯具有竞争优势。\n简单来说，就是一款语音软件，那么有的人可能会问了，那我为什么不直接使用游戏内的语音软件，或者其他的，例如 Discord 或者 YY语音呢？\n为什么我们使用 TeamSpeak为什么不用 YY 语音使用YY需要绑定个人手机，注册需要花1毛钱发短信  \n首先，先说一下广告方面，yy的弹窗和花里胡哨的推广是真的难受，而且还会占用大量的硬件系统资源和宝贵的网络带宽。\n其次，捆绑软件方面，安装 YY 后，同时会捆绑 YY浏览器等软件。\n第三，YY语音并不支持语音感应(感应麦克风，即达到一定分贝才会录入)，自由麦什么杂音都给你收进去，除此之外YY语音还会有明显的网络延迟\n除此之外，YY不授权自主建立服务器，而TeamSpeak允许用户在自己的计算机上建立32人以下的TeamSpeak服务器\n总而言之，一个语音交流软件，界面干净没有广告没有延迟，那它就是满分的语音软件,很可惜，YY没有做到上面的任意一点\n为什么不用 Discord这个原因很简单，被墙了，就算上了延迟也很高\n为什么使用 TeamSpeak首先 TeamSpeak 没有广告，没有捆绑软件，可以单独调节每个用户的音量大小等等等等。至于服务器方面，TeamSpeak 的服务器一般都是自行租赁或架设的。支持毫秒级超低延迟，适合于对语音即时通讯有严格要求的团队游戏、远程会议等场合 ，管理员可以单独调整每个玩家的语音音量。\n除此之外，如果您想的话，甚至可以在自己的服务器搭建一台 TeamSpeak 服务器。\n使用方法下载下面来说说使用方法，此处会从安装开始说起，以方便新用户进行使用。建议不要使用某国内公司制作的中文翻译版ts1.cn，该版本过旧，无法登陆现有的大部分 TeamSpeak 服务器\n第一步，下载 TeamSpeak 此处可以前往 TeamSpeak 官网 teamspeak.com 进行下载，也可以通过转存蓝奏云地址进行下载，解决国内在官网下载速度过慢的问题这里给两个下载地址：\n\nhttps://wwa.lanzoui.com/ilq7Es5231e TeamSpeak中文绿色版，不需要安装，开箱即用\nhttps://wwa.lanzoui.com/iMYHls52alg安装版，需要走一遍安装流程建议有功夫的话使用安装版ps：安装版可能需要中文语音包下载地址 https://github.com/jitingcn/TS3-Translation_zh-CN/releases\n\n连接至服务器点击主界面上面的工具栏中 连接(Connect) - 连接，在 服务器域名或地址（Server Nickname or Address） 的位置输入服务器地址（121.89.218.85 或者ts.xrervip.tk），昵称（ Nickname） 位置输入昵称后，点击 连接(Connect) 即可。PS：俺的Teamspeak地址：121.89.218.85\n常见问题如何设置感应麦？（在嘈杂的环境中对队友特别舒适）点击工具栏中的工具(Tools) ，在菜单中打开最下方设置(Options) 菜单目录 ，选择第四栏输入(Capture) 选项卡。可以在右侧的 配置 中看到 语音感应激活(Capture Voice Activation)选项，模式选择 Volume Gate。\n下方的滑杆代表感应灵敏度，您可以通过点击 开始测试(Begin test) 用平时的嗓音进行测试。一般情况下，推荐打开下方数字信号处理的回声抑制(Echo reduction) 回声消除(Echo cancellation) 以及 消除背景噪音，但具体请根据个人情况及设备的不同，自行判断。\n\n感应麦可能出现的问题？ 话别人只能听到后半句 / 录入过多杂音一般此情况为灵敏度配置不当导致的。通过调节语音感应激活中提到的滑杆，滑杆越往左越灵敏，不断地测试，找到适合自己的灵敏度即可解决此问题。\n内容抄袭自https://ts.wevg.org/why-teamspeak/\n","tags":["工具"]},{"title":"涩谷香音＆唐可可《LoveLive!Superstar!!》第3话插入歌","url":"/2021/10/18/tinystar/","content":" \n\n","tags":["二次元"]},{"title":"飞行在自由世界之巅——理所当然是GTA4","url":"/2021/10/28/Flying-on-top-of-the-free-world/","content":"\n发表于5月 30, 2008由necromanov\n\n其实本来早就想写这篇文字的，但地震的悲剧让人无法落笔。国丧终于渐渐过去了，生活又要回到正轨，那么，Blog继续更新。愿灾难后的人们能够坚强地生活下去。\n由于龙与地下城第四版核心规则书已经入手的关系，这篇我稍微写简要一点，可能也比较乱。DND4e还是个改动很大，很令人震惊的作品啊……跑题了，拉回来。\n如果一个游戏厂商有了一亿美元的游戏预算，他可以干些什么？\n这个数额对好莱坞大片来说或许并不多，但游戏业不需要花钱去请一线明星。这个数字意味着几乎没有预算限制，他可以做任何他们想要的东西。比如说，一座真实的城市——\n在虚拟世界重生的纽约，受欢乐女神而非自由女神守护的城市。当然，那女神手里抓着一个冒热气的饮料罐，而不是火炬。当这座城市2001年第一次出现在我们面前的时候，它象征着一个奇迹，一个将现实化作疯狂的奇迹，一个包罗万象的沙盘的奇迹。当它在2008年以全新的面貌重新出现的时候，我几乎看不出这座城市昔日的影子。\nDreams come true，梦想化作现实，自由城（Liberty City）出现了。在历史上最多的内容簇拥下，这个沙盘已经焕然一新。\n侠盗猎车手（Grand Theft Auto）这个名字一向以“世界上最暴力的游戏”而闻名，但它却绝不是因为暴力才获得这个惊人销量的。是的，这次的主题是GTA4，在几乎所有主要评论站点拿下满分，创下游戏史最新销售纪录的作品。各评论站点平均给了这款作品9.8分的高分——换句话说，每五个评论家中有四个人给了这款游戏满分。\n如果套用旧世代某些游戏的宣传语，大概会是这样一些口号：“二十倍于前作的新角色数量！”“充满真实感按时间作息的NPC AI！”“好莱坞水准的过场电影和编剧！”“可以和数个异性发展交往关系！”之类吧……当然，这是GTA，所以并没有这么没格调的宣传语。制作组付出了极为惊人的努力，但他们并不觉得有必要把这种努力挂在嘴边上。不管用什么标准来评判，游戏的内容量也创下了历史的新纪录：为了实现这座自由之城，制作组制作了海量的建筑、角色和动画，其中绝大多数建筑和布景存在的唯一意义是在我们飞车掠过自由城区时提供背景。在这种拟真的环境里面行走，并作出一些“超现实”风格的行动，给人一种莫名的、破坏现实的感觉——有点儿那种“后现代”的荒诞感觉。游戏没有什么新设计，但是所有的细节都重新包装过，让你几乎认不出来。但就是这些内容，Rockstar也保证了每个“市民”都有自己的原型，每类市民都有自己的动作捕捉，他们的生活和动作充满了细节。早上的中央公园里会有市民晨练甚至打太极拳，晚上的红灯区自然有妓女出没，枪战中被击伤的人会挣扎着去拿自己的武器，他们的武器掉在地下甚至还会走火。车辆的种类和细节也非常丰富，有些小地方的精细程度到了匪夷所思的境界：警车上的警笛声音会随着警笛的破坏程度而变化，车子作掩体时的防弹概率随着车头、车身和车尾的位置不同而改变，将司机击毙在位置上时会有一定概率压到方向盘而开始鸣笛。有些“怎样也好”的东西更能体现这些细节的规模：广播电台、电视节目、甚至游戏内剧场的表演，GTA4里面这些内容都被一丝不苟地做了出来。游戏内的电视是真的可以看的，和女友约会时看的喜剧也是真的有剧情有变化的。顺带一提，我很喜欢剧场里那个一定会出错的魔术师，无论是台词还是演出设计都很棒。从最后的Staff表来倒推工作量和工作强度的话，这一部分“非游戏”的内容量肯定超过了总工作量的一半。\n相对于这些“非游戏”内容量，“游戏”部分的内容量可以说相当稀少：总共只有约70个任务，支线任务的数量也被削减了。以总游戏时间、游戏内容多变性、任务数量和收集这么几个指标来看的话，游戏的内容似乎还没有罪恶都市和圣安德烈斯两代来得丰富。这实在是一种太奢侈的做法，做了那么多的内容，却只利用了极少的一小部分。就算考虑到传说中微软用五千万美元巨款买下来的“锐意制作中的两个资料片”，这种内容利用率还是奢侈得令人发指。在前几代GTA中，我玩完所有主线任务时几乎都已经背下了地图，但这一次我就算打通了也无法掌握庞大而复杂的自由城交通网（好吧，我承认这和我做任务都是打车应该很有关系……）。几乎所有的网络内容、电视内容和广播电台内容和游戏内容没有任何关系，只是看着好玩用的；绝大多数的支线任务也都没有特意展现在玩家的面前，有些甚至还藏的有些隐蔽（例如网络交友约会的内容，不看攻略真的很难找到Alex）。任务中对各种内容的展现也是惜“墨”如金：就连像自由城警方数据库这样的庞大设计，也只是在一个很简单的任务里面提到过一两次而已，在之前和之后的其他任务中再也不会出现。一开始我对这种浪费的设计思路有些难以理解，但后来我似乎逐渐明白了设计团队的想法。\nGTA4的设计目标也可以说是很清晰的：他们要的就是一个真实世界的沙盘，然后再把你丢进去随意行动。为了这个“真实”的目标，任何旧有的东西或者惯例都可以舍弃。GTA3-VC-SA三作的卡通风格被舍弃了，代之以极为写实的现实风格。收集系统大幅更新，所有“超现实”的收集（例如以前的“Hidden Package”和武器）都被删除了，代之以极为写实的隐藏要素。GTA4没有丢在野外的大包裹，也没有随意丢在路上、闪烁着光芒的武器了，只有200只“微微”闪着红光、需要用狙击枪打掉的鸽子，以及被藏在隐蔽角落里毫不起眼的武器。几个目前已经很习惯的“超游戏设计”也被放弃了：比如开始菜单、进度检查点（Checkpoint）和瞬间回血。是的，很不体贴，但是符合设计思路。GTA4肯定是历史上界面最“真实”的游戏。小地图上的线路提示只有在你坐上车，有GPS的时候才会出现，同样也会有GPS的语音指路声。你不能在主界面上看到时间的显示，因为你需要和现实世界里面一样掏出手机来看时间。同样，Minigame、偷车和赛车之类的要素也不是散布在城市各地，而是需要依靠电话和网络来组织起来。确实，这一切设计显得很麻烦，你需要打电话找兄弟买武器，需要搭车去汉堡店补血，任务失败时需要收短信重试或者读档……但当它们是作为一个“世界”的一部分时，似乎这一切都是可以忍耐的了。这些设计让我们觉得主角和我们一样，生活在一个极度依赖工具的世界里，而不是生活在一个能够在别人头顶上看到任务标志的游戏世界里。\n我们通常会说，游戏产业是个创意产业。但事实上，最好的那些游戏并不是靠创意取胜的。那些站在顶点的游戏，几乎都没有什么需要保密的创意。Mario的核心创意只是一个“跳”字，而COD4根本就没有除了“脚本”之外的任何创意。人人都知道RPG游戏的核心就是打怪升级，但有些游戏就会叫做“龙与地下城”和“魔兽世界”，有些游戏就会被飞快地遗忘。GTA4要做些、会做些什么东西，所有的人从几年前都差不多知道了——但没人有能力制作出来这样一个作品。Saint’s Row和Crackdown这样的模仿作品，在真正的GTA4面前只能用“糙”这个字来形容。GTA4告诉我们，对游戏来说，细节才是王。一个实现的好的设计，胜过十个有新意但是拼凑得很随意的设计。\n最后顺便提一下游戏的剧情。GTA4的整个剧本似乎只是由两名编剧写出的，故事的紧张程度和紧凑程度感觉比以前提高了很多。主角Nico Bellic身为一个前俄国军人，也不再是以前GTA系列那种比较简单化的自由黑帮形象，而是一个比较有深度的角色了。整个剧情围绕着“复仇”和“夺宝（钻石）”两条主线展开，每条主线都贯穿十来个任务，最后的结局也都很出人意料，确实配的上“Great Story”这个说法。果然设计长任务线和让编剧人数减少才是提高剧本质量的最好方法么……\n"}]